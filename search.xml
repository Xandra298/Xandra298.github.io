<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Learning Multimodal Violence Detection under Weak Supervision</title>
    <url>/posts/undefined/</url>
    <content><![CDATA[<h1 id="Not-only-look-but-also-listen-Learning-multimodal-violence-detection-under-weak-supervision"><a href="#Not-only-look-but-also-listen-Learning-multimodal-violence-detection-under-weak-supervision" class="headerlink" title="Not only look, but also listen: Learning multimodal violence detection under weak supervision"></a>Not only look, but also listen: Learning multimodal violence detection under weak supervision</h1><p><a href="https://arxiv.org/pdf/2007.04687.pdf">paper</a> ，<a href="https://roc-ng.github.io/XD-Violence/">code and dataset</a></p>
<p>暴力视频检测方向论文</p>
<blockquote>
<p> 💡 We introduce a HL-Net to simultaneously capture <strong>long-range relations</strong> and<br><strong>local distance relations</strong>, of which these two relations are based on similarity prior and proximity prior, respectively</p>
<p>三个并行的branch捕捉视频片段和集成的特征之间的不同联系:</p>
<ul>
<li>holistic branch captures long-range dependencies using similarity prior,</li>
<li>localized branch captures local positional relation using proximity prior,</li>
<li>score branch dynamically captures the closeness of predicted score.</li>
</ul>
</blockquote>
<span id="more"></span>
<p>相关工作，其中attention部分可以后面看下；</p>
<p>一些工作将图神经网络(GCNs)[20,39]在图上建立不同节点之间的关系模型，并学习计算机视觉的强大表示。例如，GCN被用于时间性动作定位[50]、视频分类[37,41]、异常检测[51]。基于骨架的动作识别[33,45]，点云语义分割[21]，图像说明[46]等等。除了GCN，时间关系网络[52]，旨在学习和推理视频帧之间的时间依赖关系，被提出来用于解决视频分类。最近，自我注意网络[40,47,5,18]已被成功应用于视觉问题。注意力操作可以通过聚合一组元素的信息来影响单个元素，其中聚合的权重是自动学习的。</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="总体框架图"><a href="#总体框架图" class="headerlink" title="总体框架图"></a>总体框架图</h2><p><img src="/posts/undefined/Untitled.png" alt></p>
<ul>
<li><p>特征提取：using the sliding window mechanism 提取 视频特征和声音特征，合并成融合特征（融合部分不予关注。滑动窗口机制待看）</p>
<blockquote>
<p>Visual features: utilize two mainstream networks-C3D and I3D networks. we extract fc6 features from C3D that is pretrained on the Sports-1M dataset, and extract global_pool features from I3D pre-trained on Kinetics-200 dataset.</p>
</blockquote>
</li>
</ul>
<h2 id="Holistic-and-Localized-Networks"><a href="#Holistic-and-Localized-Networks" class="headerlink" title="Holistic and Localized Networks"></a>Holistic and Localized Networks</h2><h3 id="Holistic-特征相似性"><a href="#Holistic-特征相似性" class="headerlink" title="Holistic - 特征相似性"></a><strong>Holistic - 特征相似性</strong></h3><hr>
<p>通用的图卷积表示可以看为：</p>
<script type="math/tex; mode=display">
X_l+1 = Update(Aggregate(X_l,W_l^{agg},W_l^{update}))</script><ul>
<li><strong>GCN范式：</strong><script type="math/tex; mode=display">
X^H_{l+1} = Dropout(ReLU(A^HX^H_lW^H_l))</script></li>
</ul>
<p>注：$X^H_0 = X^S_0 = X^L_0 = X^F$</p>
<p><strong>特征相似性的邻接矩阵表示:</strong></p>
<script type="math/tex; mode=display">
A^H_{ij} = g(f(x_i,x_j))</script><p>$A^H_{ij}$衡量第i个和第j个特征的特征相似性；g是归一化函数，f函数计算一对特征的相似性；附录部分还讨论了一下其他版本的。本文定义如下</p>
<ul>
<li>f 定义为：</li>
</ul>
<script type="math/tex; mode=display">
f(x_i,x_j) = \frac{x_i^Tx_j}{||x_i||_{2} \\ . \\ ||x_j||_2}</script><ul>
<li>thresholding操作（$\tau$是threshod，f将相似性限制在（0,1]之间）：</li>
</ul>
<script type="math/tex; mode=display">
f(x_i,x_j) = \begin{cases} f(x_i,x_j)  & f(x_i,x_j) > \tau \\ 0 & f(x_i,x_j)\leq \tau\end{cases}</script><ul>
<li><p>使用softmax作为归一化函数g，使得A的每一行的和都为1。</p>
<script type="math/tex; mode=display">
A^H_{ij} = \frac{exp(A^H_{ij})}{\sum ^{T'}_{k=1} exp(A^H_{ij})}</script></li>
</ul>
<h3 id="localized-branch-proximity-prior-和时间一致性类似）"><a href="#localized-branch-proximity-prior-和时间一致性类似）" class="headerlink" title="localized branch -proximity prior (和时间一致性类似）"></a><strong>localized branch -proximity prior (和时间一致性类似）</strong></h3><hr>
<script type="math/tex; mode=display">
A^L_{ij} = exp(\frac{-|i-j|^r}{\sigma })</script><h2 id="Online-detection-amp-score-branch"><a href="#Online-detection-amp-score-branch" class="headerlink" title="Online detection &amp; score branch"></a>Online detection &amp; score branch</h2><p>正如我们提到的，暴力检测系统不仅适用于离线检测（互联网录像机），也适用于在线检测（监控系统）。然而，<strong>上述HL-Net</strong>的在线检测受到了一个主要障碍的阻碍：<strong>HL-Net需要整个视频来获得长距离的依赖关系</strong>。为了跳出这个困境，我们提出了一个HLC近似器，只把以前的视频片段作为输入，在HL-Net的指导下产生精确的预测。两个堆叠的FC层和ReLU以及一个一维因果卷积层构成了HLC近似器。一维因果卷积层的核大小为5，跨度为1，在时间上滑动卷积滤波器。一维因果卷积层也充当分类器，其输出是形状为 T’ 的暴力激活表示为$C^S$。更妙的是，这个操作引入了一个额外的分支，名为<strong>动态得分分支(dynamic score branch)</strong>，以扩展HL-Net，它取决于$C^S$。</p>
<h3 id="score-branch"><a href="#score-branch" class="headerlink" title="score branch"></a>score branch</h3><p>用于online detection, 解决需要将整个视频作为输入（以获得长距离依赖）的问题。</p>
<p>该分支的主要作用是将一个位置的响应计算为所有位置特征的加权和，其中权重取决于分数的接近程度。与整体和局部分支的关系矩阵不同，分数分支的关系矩阵在每次迭代中都会更新，并且取决于预测的分数而不是先验。从形式上看，分数分支的关系矩阵设计如下：</p>
<script type="math/tex; mode=display">
A^S_{ij} = \rho(1 - |s(C^S_i) - s(C^S_j)|)</script><p>s是 sigmoid, 函数ρ用于加强（和削弱）得分接近度大于（和小于）0.5的配对关系，softmax也用于归一化。</p>
<script type="math/tex; mode=display">
\rho (x) = \frac{1}{1+exp(-\frac{x-0.5}{0.1})}</script><h2 id="training-based-on-MIL"><a href="#training-based-on-MIL" class="headerlink" title="training based on MIL"></a>training based on MIL</h2><script type="math/tex; mode=display">
C^P = (X^H||X^L||X^S)W</script><p>所有输出($C^P 和 C^S$)在时间维度上的K-max取平均作为输出，以得到$y^P$ 和$y^S$。K定义为T‘ 除以q加一后向下取整。</p>
<p>补充： top-k策略（Weakly-supervised video anomaly detection with robust temporal feature magnitude learning）</p>
<ul>
<li>loss结合三个branch</li>
</ul>
<blockquote>
<p>The instances corresponding to the K-max activation in the positive bag is most likely to be true positive instances (violence). The instances corresponding to the K-max activation in the negative bag is hard instances. We expect these two types of instances to be as far as possible.</p>
</blockquote>
<p>L_BCE（binary crossentropy) 和L_BCE2分别对应为$y^p 和 y^s$ 与 ground truth y之间的loss。L_DISTILL为知识蒸馏损失。</p>
<script type="math/tex; mode=display">
L_{TOTAL}  = L_{BCE} + L_{BCE2} +\lambda L_{DISTILL}</script><script type="math/tex; mode=display">
L_{DISTILL} = \sum \limits^N_{j=1} (- \sum \limits_i s(C^P_i) log (s(C_i^S)))</script><h2 id="Inference"><a href="#Inference" class="headerlink" title="Inference"></a>Inference</h2><p>方法支持线上和离线的检测。sigmoid函数作为$C^P$和$C^S$的激活函数，并最后生成在[0,1]之间的暴力置信得分。注：在线上预测中，只有HLC近似器工作，HL-NET可以移除。</p>
<h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><h2 id="评估标准"><a href="#评估标准" class="headerlink" title="评估标准"></a>评估标准</h2><p>we utilize the frame-level <strong>precision-recall curve</strong> (PRC) and corresponding area under the curve <strong>(average precision, AP)</strong> [30] rather than receiver operating characteristic curve (ROC) and corresponding area under the curve (AUC) [44,43]<br><strong>since AUC usually shows an optimistic result when dealing with class-imbalanced data, and PRC and AP focus on positive samples (violence)</strong></p>
<ul>
<li>Precision and Recall (PR曲线)：用于稀有事件检测，如目标检测、信息检索、推荐系统。负样本很多的时候，??? = FP⁄(FP+TN）很小，比较TPR和FPR没有太大意义（ROC）</li>
</ul>
<h2 id="性能表现"><a href="#性能表现" class="headerlink" title="性能表现"></a>性能表现</h2><p><img src="/posts/undefined/Untitled 1.png" alt></p>
<p>优于当前最先进的方法（20年的文章）</p>
<p>我们观察到，在我们的暴力检测任务中，C3D比I3D差了很大一截。</p>
<h2 id="消融实验"><a href="#消融实验" class="headerlink" title="消融实验"></a>消融实验</h2><ul>
<li>五种模态AP对比</li>
</ul>
<p><img src="/posts/undefined/Untitled 2.png" alt="Untitled"></p>
<p>（该文证明声音和视觉的融合检测效果更好，且视觉模态的作用优于声音）</p>
<ul>
<li><p>三个分支的对比（holistic, localized and score branches）</p>
<ul>
<li>三个分支单独的情况表现相似</li>
<li>移除任何一个分支都会使得表现变差</li>
<li>HL-NET在这三个分支一起作用的时候表现最好，因此证明三个分支都不可替代。</li>
</ul>
<p><img src="/posts/undefined/Untitled 3.png" alt></p>
</li>
<li><p>online vs offline</p>
<p><img src="/posts/undefined/Untitled 4.png" alt></p>
</li>
</ul>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h3 id="光流"><a href="#光流" class="headerlink" title="光流"></a>光流</h3><blockquote>
<p>光流（optical flow）是空间运动物体在观察成像平面上的像素运动的瞬时速度。<br>光流法是利用图像序列中像素在时间域上的变化以及相邻帧之间的相关性来找到上一帧跟当前帧之间存在的对应关系，从而计算出相邻帧之间物体的运动信息的一种方法。<br>通常将二维图像平面特定坐标点上的灰度瞬时变化率定义为光流矢量。</p>
</blockquote>
<p>作者在《On the Integration of Optical Flow and Action Recognition》这篇文章[1]中深入讨论了光流与行为识别的结合，并通过实验观察到如下结论：<br>（1）光流对于行为识别是有用的，因为它的外观不变性；<br>（2）光流法采用最小化端点误差（EPE，end-point-error）来优化，但是当前EPE方法与动作识别性能没有很好的相关性；<br>（3）对于测试过的光流方法，在边界上和小位移上的精度与动作识别性能最相关；<br>（4）采用最小化分类误差（而非EPE）来训练光流可以提高识别性能；<br>（5）用于行为识别任务的光流不同于传统的光流，特别是在人体内部和身体边界处。<br>原文链接：<a href="https://blog.csdn.net/zhang_can/article/details/80259946">https://blog.csdn.net/zhang_can/article/details/80259946</a></p>
]]></content>
      <categories>
        <category>视频检测</category>
      </categories>
      <tags>
        <tag>深度视频检测</tag>
        <tag>暴力视频检测</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo Hello World</title>
    <url>/posts/1e44dbaf/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>hexo配置</category>
      </categories>
  </entry>
  <entry>
    <title>pytorchlearning</title>
    <url>/posts/643f7c73/</url>
    <content><![CDATA[<h1 id="pytorch-学习记录"><a href="#pytorch-学习记录" class="headerlink" title="pytorch 学习记录"></a>pytorch 学习记录</h1><span id="more"></span>
<p>视频学习笔记github存储仓库：（@ljh）</p>
<p><a href="https://github.com/Xandra298/Pytorchlearning">Xandra298/Pytorchlearning (github.com)</a></p>
<ul>
<li><p>torch基础操作</p>
<p><a href="https://github.com/Xandra298/Pytorchlearning/blob/all/3.pytorch基础操作.ipynb">Pytorchlearning/3.pytorch基础操作.ipynb at all · Xandra298/Pytorchlearning (github.com)</a></p>
</li>
<li><p>自定义数据集预处理与加载</p>
<p><a href="https://xandra298.github.io/posts/a0ca199b/">【pytorch learning】(一)自定义数据集预处理和加载</a></p>
</li>
<li><p>完整模型搭建、训练、测试</p>
<p><a href="https://xandra298.github.io/posts/13fc6476/">【pytorch-learning】(二) 模型搭建-训练-测试 </a></p>
</li>
<li><p>可视化</p>
<p><a href="https://xandra298.github.io/posts/f19419c5/">【pytorch-learning】(三) 可视化 </a></p>
</li>
<li><p>【理论】随机梯度下降</p>
<p>包括损失函数等:  <a href="https://github.com/Xandra298/Pytorchlearning/blob/all/4.随机梯度下降.ipynb">笔记</a></p>
</li>
<li><p>过拟合及优化trick</p>
<p><a href="https://github.com/Xandra298/Pytorchlearning/blob/all/7. 过拟合及优化trick.ipynb">Pytorchlearning/过拟合及优化trick</a></p>
</li>
<li><p>卷积神经网络: <a href="https://github.com/Xandra298/Pytorchlearning/blob/all/8.卷积神经网络.ipynb">笔记</a></p>
</li>
<li><p>循环神经网络: <a href="https://github.com/Xandra298/Pytorchlearning/blob/all/9.循环神经网络.ipynb">笔记</a></p>
</li>
<li><p>自编码器: <a href="https://github.com/Xandra298/Pytorchlearning/blob/master/10.自编码器.ipynb">笔记</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>【pytorch learning】(一)自定义数据集预处理和加载</title>
    <url>/posts/a0ca199b/</url>
    <content><![CDATA[<h1 id="通用实现"><a href="#通用实现" class="headerlink" title="通用实现"></a>通用实现</h1><p>关键库：Dataset和 DataLoader</p>
<p><code>from torch.utils.data import  Dataset,DataLoader</code></p>
<p>代码使用数据集：<a href="https://github.com/Xandra298/Pytorchlearning/tree/master/pokeman">宝可梦</a></p>
<span id="more"></span>
<p>该数据集目录格式为：</p>
<p> root dir:</p>
<ul>
<li>dir1(name is the class)<ul>
<li>pic1</li>
<li>pic2</li>
<li>…</li>
</ul>
</li>
<li>dir2(name is the class)<ul>
<li>…</li>
</ul>
</li>
</ul>
<h2 id="Dataset"><a href="#Dataset" class="headerlink" title="Dataset"></a>Dataset</h2><p>继承Dataset类的实现</p>
<p>需要重载方法：</p>
<ul>
<li>__len__:返回数据集长度（数据数量）</li>
<li>__get_item__：获取数据集的item</li>
</ul>
<p>关键思路：具体见代码及代码注释</p>
<p>自定义方法load_csv:</p>
<ol>
<li>遍历目录，将image_path-label存储到csv文件中：</li>
</ol>
<ul>
<li>用<code>glob.glob</code>获取具体路径的数据路径</li>
<li><code>csv.writer(f)</code>将image_path,label写入csv文件</li>
</ul>
<ol>
<li>读取csv文件，获得image_path-label</li>
</ol>
<ul>
<li>reader = <code>csv.reader(f)</code>，for row in reader:…</li>
</ul>
<p>len方法：</p>
<ul>
<li>返回数据集长度</li>
</ul>
<p>get_item方法：</p>
<ul>
<li><p>传入index,从我们全局的列表中获得对应的数据</p>
</li>
<li><p>通过读取csv文件，传入index, 可以获得对应的image_path - label对。</p>
<p>目标：载入image_path，处理图片，返回符合要求的图片数据和label对</p>
</li>
<li><p>处理从路径上读取的数据，返回指定格式。如使用<code>torchvision.transform</code>，最后处理完的格式是tensor</p>
</li>
<li><p>返回数据和label对</p>
</li>
</ul>
<p>关于mode，可以通过判断需要训练集或者测试集这样子，返回切分后的数据集</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> os,glob</span><br><span class="line"><span class="keyword">import</span> random,csv</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset,DataLoader</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pokemen</span>(<span class="title class_ inherited__">Dataset</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,root,resize,mode</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :param root: root dir of dataset</span></span><br><span class="line"><span class="string">                    root dir:</span></span><br><span class="line"><span class="string">                        - dir1(name is the class)</span></span><br><span class="line"><span class="string">                            - pic1</span></span><br><span class="line"><span class="string">                            - pic2</span></span><br><span class="line"><span class="string">                            - ...</span></span><br><span class="line"><span class="string">                        - dir2(name is the class)</span></span><br><span class="line"><span class="string">                        - ...</span></span><br><span class="line"><span class="string">        :param resize:</span></span><br><span class="line"><span class="string">        :param mode: train\test\val</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="built_in">super</span>(Pokemen, self).__init__()</span><br><span class="line">        self.root = root</span><br><span class="line">        self.resize = resize</span><br><span class="line"></span><br><span class="line">        self.name2label = &#123;&#125;<span class="comment">#  save the dict &#123;name:int&#125; </span></span><br><span class="line">        <span class="comment">#list the dir name under the root dir</span></span><br><span class="line">        <span class="keyword">for</span> name <span class="keyword">in</span> <span class="built_in">sorted</span>(os.listdir(os.path.join(root))): <span class="comment"># sorted to ensure every time to be the same</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> os.path.isdir(os.path.join(root,name)):</span><br><span class="line">                <span class="comment"># not a dir</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># get the name:int following the order</span></span><br><span class="line">            self.name2label[name] = <span class="built_in">len</span>(self.name2label.keys())</span><br><span class="line">        <span class="built_in">print</span>(self.name2label)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># read from csv: image_path-label；</span></span><br><span class="line">        <span class="comment"># function load_csv：save the image_path-label to csv and then read from csv</span></span><br><span class="line">        self.images,self.labels = self.load_csv(<span class="string">&quot;image.csv&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#split dataset</span></span><br><span class="line">        <span class="keyword">if</span> mode == <span class="string">&#x27;train&#x27;</span>: <span class="comment">#60%</span></span><br><span class="line">            self.images = self.images[:<span class="built_in">int</span>(<span class="number">0.6</span>*<span class="built_in">len</span>(self.images))]</span><br><span class="line">            self.labels = self.labels[:<span class="built_in">int</span>(<span class="number">0.6</span>*<span class="built_in">len</span>(self.labels))]</span><br><span class="line">        <span class="keyword">elif</span> mode == <span class="string">&#x27;val&#x27;</span>: <span class="comment">#20%</span></span><br><span class="line">            self.images = self.images[<span class="built_in">int</span>(<span class="number">0.6</span> * <span class="built_in">len</span>(self.images)):<span class="built_in">int</span>(<span class="number">0.8</span>*<span class="built_in">len</span>(self.images))]</span><br><span class="line">            self.labels = self.labels[<span class="built_in">int</span>(<span class="number">0.6</span> * <span class="built_in">len</span>(self.labels)):<span class="built_in">int</span>(<span class="number">0.8</span>*<span class="built_in">len</span>(self.labels))]</span><br><span class="line">        <span class="keyword">elif</span> mode == <span class="string">&#x27;test&#x27;</span>:</span><br><span class="line">            self.images = self.images[<span class="built_in">int</span>(<span class="number">0.8</span> * <span class="built_in">len</span>(self.images)):]</span><br><span class="line">            self.labels = self.labels[<span class="built_in">int</span>(<span class="number">0.8</span> * <span class="built_in">len</span>(self.labels)):]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">load_csv</span>(<span class="params">self,filename</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        save image_path-label to csv(if csv exits,just read from it) ，and then read from it</span></span><br><span class="line"><span class="string">        :param filename: filepath of the csv to save and read</span></span><br><span class="line"><span class="string">        :return: images,labels==&gt; images_path,labels</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        savepath = os.path.join(self.root,filename)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(savepath):</span><br><span class="line">            images = []</span><br><span class="line">            <span class="keyword">for</span> name <span class="keyword">in</span> self.name2label.keys():</span><br><span class="line">                <span class="comment">#grop the pic, save to list</span></span><br><span class="line">                images += glob.glob(os.path.join(self.root,name,<span class="string">&#x27;*.png&#x27;</span>))</span><br><span class="line">                images += glob.glob(os.path.join(self.root, name, <span class="string">&#x27;*.jpg&#x27;</span>))</span><br><span class="line">                images += glob.glob(os.path.join(self.root, name, <span class="string">&#x27;*.gif&#x27;</span>))</span><br><span class="line">            <span class="comment">#print(images)</span></span><br><span class="line">            <span class="comment">#&#x27;./pokeman/squirtle\\00000073.png&#x27;</span></span><br><span class="line">            random.shuffle(images) <span class="comment">#shuffle</span></span><br><span class="line">            <span class="comment">#write into csv</span></span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(savepath,mode=<span class="string">&#x27;w&#x27;</span>,newline=<span class="string">&#x27;&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                writer = csv.writer(f)</span><br><span class="line">                <span class="keyword">for</span> img <span class="keyword">in</span> images:</span><br><span class="line">                    name = img.split(os.sep)[-<span class="number">2</span>]</span><br><span class="line">                    label = self.name2label[name]</span><br><span class="line">                    writer.writerow([img,label])</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;written into csv file:&#x27;</span>,savepath)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#read from csv</span></span><br><span class="line">        images,labels = [],[]</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(savepath) <span class="keyword">as</span> f:</span><br><span class="line">            reader = csv.reader(f)</span><br><span class="line">            <span class="keyword">for</span> row <span class="keyword">in</span> reader:</span><br><span class="line">                img,label = row</span><br><span class="line">                label = <span class="built_in">int</span>(label)</span><br><span class="line">                images.append(img)</span><br><span class="line">                labels.append(label)</span><br><span class="line">        <span class="keyword">assert</span>  <span class="built_in">len</span>(images) == <span class="built_in">len</span>(labels)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>  images,labels</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        :return: len of dataset</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.images)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :param item: range in [0,len(images)]</span></span><br><span class="line"><span class="string">        :return: self.images,self.labels</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">        img,label = self.images[item],self.labels[item]</span><br><span class="line"></span><br><span class="line">        tf = transforms.Compose(</span><br><span class="line">            [<span class="keyword">lambda</span> x:Image.<span class="built_in">open</span>(x).convert(<span class="string">&#x27;RGB&#x27;</span>), <span class="comment"># open image and convert to RGB</span></span><br><span class="line">             transforms.Resize((<span class="built_in">int</span>(self.resize*<span class="number">1.25</span>),<span class="built_in">int</span>(self.resize*<span class="number">1.25</span>))), <span class="comment"># resize</span></span><br><span class="line">             transforms.RandomRotation(<span class="number">15</span>), <span class="comment"># rotate</span></span><br><span class="line">             transforms.CenterCrop(self.resize), <span class="comment">#center crop</span></span><br><span class="line">             transforms.ToTensor(),</span><br><span class="line">             transforms.Normalize(mean=[<span class="number">0.485</span>,<span class="number">0.456</span>,<span class="number">0.406</span>],std=[<span class="number">0.229</span>,<span class="number">0.224</span>,<span class="number">0.225</span>]),<span class="comment">#values computed from ImageNet，we could use it in other dataset</span></span><br><span class="line"></span><br><span class="line">             ]</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        img = tf(img)</span><br><span class="line">        label = torch.tensor(label)</span><br><span class="line">        <span class="keyword">return</span> img,label</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">denormalize</span>(<span class="params">self,x_hat</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        x_hat = (x - mean)/std</span></span><br><span class="line"><span class="string">        x = x_hat * std + mean</span></span><br><span class="line"><span class="string">        :param x_hat: shape[3,self.resize,self.resize]</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        mean = [<span class="number">0.485</span>, <span class="number">0.456</span>, <span class="number">0.406</span>]</span><br><span class="line">        std = [<span class="number">0.229</span>, <span class="number">0.224</span>, <span class="number">0.225</span>]</span><br><span class="line">        mean = torch.tensor(mean).unsqueeze(<span class="number">1</span>).unsqueeze(<span class="number">1</span>)</span><br><span class="line">        std = torch.tensor(std).unsqueeze(<span class="number">1</span>).unsqueeze(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        x = x_hat*std+mean</span><br><span class="line">        <span class="keyword">return</span>  x</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># dataset</span></span><br><span class="line">    db_train = Pokemen(root=<span class="string">&#x27;pokeman&#x27;</span>,resize=<span class="number">224</span>,mode=<span class="string">&#x27;train&#x27;</span>)</span><br><span class="line">    <span class="comment"># dataloader</span></span><br><span class="line">    dl_train = DataLoader(dataset=db_train,batch_size=<span class="number">32</span>,shuffle=<span class="literal">True</span>)</span><br><span class="line">    x,y = <span class="built_in">next</span>(<span class="built_in">iter</span>(dl_train))</span><br><span class="line">    <span class="built_in">print</span>(x.shape,y.shape)</span><br></pre></td></tr></table></figure>
<pre><code>&#123;&#39;.ipynb_checkpoints&#39;: 0, &#39;bulbasaur&#39;: 1, &#39;charmander&#39;: 2, &#39;mewtwo&#39;: 3, &#39;pikachu&#39;: 4, &#39;squirtle&#39;: 5&#125;
written into csv file: pokeman\image.csv
torch.Size([32, 3, 224, 224]) torch.Size([32])
</code></pre><h2 id="DataLoader"><a href="#DataLoader" class="headerlink" title="DataLoader"></a>DataLoader</h2><p>传入数据集，处理为batch。主要参数：batch_size</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dl_train = DataLoader(dataset=db_train,batch_size=<span class="number">32</span>,shuffle=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>其他常用参数：</p>
<ul>
<li>num_workers ( int, optional): how many subprocesses to use for data loading. <code>0</code> means that the data will be loaded in the main process. (default: <code>0</code>)</li>
<li>drop_last (bool, optional): set to <code>True</code> to drop the last incomplete batch, if the dataset size is not divisible by the batch size. If <code>False</code> and  the size of dataset is not divisible by the batch size, then the last batch will be smaller. (default: <code>False</code>)</li>
</ul>
<p>官方文档：<a href="https://pytorch.org/docs/stable/data.html?highlight=dataloader#torch.utils.data.DataLoader">torch.utils.data — PyTorch 1.13 documentation</a></p>
<p>dl_train返回的参数对应dataset get_item的return 参数</p>
<ul>
<li><p><code>x,y = next(iter(dataset))</code></p>
</li>
<li><p><code>X,Y = next(iter(dataloader))</code></p>
</li>
</ul>
<p>X.shape == (batchsize,x.shape)</p>
<p><strong>进行训练时的一般模式：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> idx,(x,label) <span class="keyword">in</span> <span class="built_in">enumerate</span>(dl_train):</span><br><span class="line">	x,label = x.to(device),y.to(device)</span><br><span class="line">	pred = model(x)</span><br><span class="line">	loss = lossFunction(pred,label)</span><br><span class="line">	optimizer.zero_grad()</span><br><span class="line">	loss.backward()</span><br><span class="line">	loss.step()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="特殊便捷方式数据集加载"><a href="#特殊便捷方式数据集加载" class="headerlink" title="特殊便捷方式数据集加载"></a>特殊便捷方式数据集加载</h1><p>使用函数<code>datasets.ImageFolder</code> </p>
<p>使用场景：适用于将数据集分文件夹存储，文件夹名称为对应的label</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tf  = transforms.Compose([</span><br><span class="line">    transforms.Resize((<span class="number">128</span>,<span class="number">128</span>)),</span><br><span class="line">    transforms.ToTensor()</span><br><span class="line">])</span><br><span class="line"><span class="comment">##适用于将数据集分文件夹存储，文件夹名称为对应的label</span></span><br><span class="line">db = torchvision.datasets.ImageFolder(root=<span class="string">&#x27;./pokeman/&#x27;</span>,transform=tf)</span><br><span class="line">loader = DataLoader(db,batch_size=<span class="number">32</span>,shuffle=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(db.class_to_idx)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>【pytorch-learning】(三) 可视化</title>
    <url>/posts/f19419c5/</url>
    <content><![CDATA[<h1 id="tensorboard的使用"><a href="#tensorboard的使用" class="headerlink" title="tensorboard的使用"></a>tensorboard的使用</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install tensorboard</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="add-scalar"><a href="#add-scalar" class="headerlink" title="add_scalar"></a>add_scalar</h3><h4 id="运行代码"><a href="#运行代码" class="headerlink" title="运行代码"></a><strong>运行代码</strong></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span>  SummaryWriter</span><br><span class="line">writer = SummaryWriter(<span class="string">&quot;logs&quot;</span>)<span class="comment"># 保存log的文件夾</span></span><br><span class="line"><span class="comment">##y=x</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line"></span><br><span class="line">    writer.add_scalar(<span class="string">&quot;y=2x&quot;</span>,<span class="number">2</span>*i,i)</span><br><span class="line"></span><br><span class="line">writer.close()</span><br></pre></td></tr></table></figure>
<h4 id="命令行运行：打开事件文件"><a href="#命令行运行：打开事件文件" class="headerlink" title="命令行运行：打开事件文件"></a><strong>命令行运行：打开事件文件</strong></h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tensorboard --logdir=logs --port=6007</span><br></pre></td></tr></table></figure>
<p>tensorboard参数： —logdir=文件夹名称 —port=端口号 可以不设置端口号就是默认，为了避免冲突可以设置</p>
<p>由于多次添加，导致log文件中有各种，可能导致tensorboard显示曲线的一些拟合等。</p>
<p>解决：</p>
<ul>
<li>删除logs文件夹下的文件，重新运行程序。</li>
<li>对应每个任务每次都设立子文件夹。</li>
</ul>
<h4 id="浏览器查看"><a href="#浏览器查看" class="headerlink" title="浏览器查看"></a><strong>浏览器查看</strong></h4><p>网址在命令行有显示。前面示例的为 localhost:6007。</p>
<h3 id="add-image"><a href="#add-image" class="headerlink" title="add_image"></a>add_image</h3><p>图片</p>
<p>数据类型需要tensor或者numpy array</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span>  SummaryWriter</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">writer = SummaryWriter(<span class="string">&quot;logs&quot;</span>)</span><br><span class="line">img_path = <span class="string">&quot;./hymenoptera_data/hymenoptera_data/train/ants/0013035.jpg&quot;</span></span><br><span class="line">img_PIL = Image.<span class="built_in">open</span>(img_path)</span><br><span class="line">img_array = np.array(img_PIL)</span><br><span class="line"><span class="built_in">print</span>(img_array.shape)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(img_array))</span><br><span class="line">writer.add_image(<span class="string">&quot;test&quot;</span>,img_array,<span class="number">1</span>,dataformats=<span class="string">&quot;HWC&quot;</span>)<span class="comment">##默认是CHW,如果不是需要进行设置</span></span><br><span class="line"></span><br><span class="line">writer.close()</span><br></pre></td></tr></table></figure>
<h3 id="add-graph"><a href="#add-graph" class="headerlink" title="add_graph"></a>add_graph</h3><p>可视化模型</p>
<ul>
<li>代码中使用tensorboard的add_graph将模型加入，注意传参需要传入模型输入。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> Conv2d, MaxPool2d, Linear, Sequential</span><br><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Model</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(Model, self).__init__()</span><br><span class="line">        self.model1 = Sequential(</span><br><span class="line">            Conv2d(<span class="number">3</span>, <span class="number">32</span>, kernel_size=<span class="number">5</span>, padding=<span class="number">2</span>),</span><br><span class="line">            MaxPool2d(<span class="number">2</span>),</span><br><span class="line">            Conv2d(<span class="number">32</span>, <span class="number">32</span>, <span class="number">5</span>, padding=<span class="number">2</span>),</span><br><span class="line">            MaxPool2d(<span class="number">2</span>),</span><br><span class="line">            Conv2d(<span class="number">32</span>, <span class="number">64</span>, <span class="number">5</span>, padding=<span class="number">2</span>),</span><br><span class="line">            MaxPool2d(<span class="number">2</span>),</span><br><span class="line">            nn.Flatten(),</span><br><span class="line">            Linear(<span class="number">1024</span>, <span class="number">64</span>),</span><br><span class="line">            Linear(<span class="number">64</span>, <span class="number">10</span>)</span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self,x</span>):</span><br><span class="line">        x = self.model1(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">model = Model()</span><br><span class="line"><span class="built_in">print</span>(model)</span><br><span class="line"></span><br><span class="line"><span class="built_in">input</span> = torch.ones(<span class="number">64</span>,<span class="number">3</span>,<span class="number">32</span>,<span class="number">32</span>)</span><br><span class="line">output = model(<span class="built_in">input</span>)</span><br><span class="line"><span class="built_in">print</span>(output.shape)</span><br><span class="line"></span><br><span class="line">writer = SummaryWriter(<span class="string">&quot;logs_seq&quot;</span>)</span><br><span class="line">writer.add_graph(model,<span class="built_in">input</span>)</span><br><span class="line">writer.close()</span><br></pre></td></tr></table></figure>
<ul>
<li><p>命令行运行命令打开事件文件</p>
</li>
<li><p>浏览器查看模型，可以点击放大，看模型具体层</p>
</li>
</ul>
<p><img src="/posts/f19419c5/模型.png" alt="tensorboard查看"></p>
<h1 id="Visdom可视化"><a href="#Visdom可视化" class="headerlink" title="Visdom可视化"></a>Visdom可视化</h1><p>窗口视图，界面友好</p>
<h2 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h2><ul>
<li>方式一</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install visdom</span><br></pre></td></tr></table></figure>
<p>命令行运行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python -m visdom.server</span><br></pre></td></tr></table></figure>
<p>如果报错找不到路径，解决方式：在该目录下自己创建该文件夹</p>
<ul>
<li>安装方式2：避免download问题</li>
</ul>
<ol>
<li>pip uninstall visdom</li>
<li>从github下载visdom文件</li>
<li>cd 该目录下，pip install -e .</li>
<li>在项目路径下 python -m visdom.server成功启动</li>
</ol>
<h2 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h2><p>visdom的一些具体使用：<a href="https://blog.csdn.net/weixin_41010198/article/details/117853358">https://blog.csdn.net/weixin_41010198/article/details/117853358</a></p>
<h4 id="一个使用实例"><a href="#一个使用实例" class="headerlink" title="一个使用实例"></a><strong>一个使用实例</strong></h4><ol>
<li>命令行运行<code>python -m visdom.server</code>成功启动</li>
<li>运行代码</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> visdom <span class="keyword">import</span> Visdom</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">loss = torch.rand(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">global_step = torch.arange(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">viz = Visdom()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">viz.line([<span class="number">0.</span>],[<span class="number">0.</span>],win=<span class="string">&#x27;train_loss&#x27;</span>,opts = <span class="built_in">dict</span>(title=<span class="string">&#x27;train_loss&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> idx,lossi <span class="keyword">in</span> <span class="built_in">enumerate</span>(loss):</span><br><span class="line">   </span><br><span class="line">    viz.line([lossi.item()],[idx],win = <span class="string">&#x27;train_loss&#x27;</span>,update=<span class="string">&#x27;append&#x27;</span>)</span><br></pre></td></tr></table></figure>
<ol>
<li>浏览器查看</li>
</ol>
<p><img src="/posts/f19419c5/image-20221124200104212.png" alt="浏览器视图" style="zoom:67%;"></p>
<h4 id="完整模型训练测试过程中使用visdom可视化"><a href="#完整模型训练测试过程中使用visdom可视化" class="headerlink" title="完整模型训练测试过程中使用visdom可视化"></a>完整模型训练测试过程中使用visdom可视化</h4><p><a href="https://github.com/Xandra298/Pytorchlearning/tree/master/mnist data/MNIST">手写数字识别数据集</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>  torch</span><br><span class="line"><span class="keyword">import</span>  torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span>  torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">import</span>  torch.optim <span class="keyword">as</span> optim</span><br><span class="line"><span class="keyword">from</span>    torchvision <span class="keyword">import</span> datasets, transforms</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> visdom <span class="keyword">import</span> Visdom</span><br><span class="line"></span><br><span class="line">batch_size=<span class="number">200</span></span><br><span class="line">learning_rate=<span class="number">0.01</span></span><br><span class="line">epochs=<span class="number">2</span></span><br><span class="line"></span><br><span class="line">train_loader = torch.utils.data.DataLoader(</span><br><span class="line">    datasets.MNIST(<span class="string">&#x27;./mnist data/&#x27;</span>, train=<span class="literal">True</span>, download=<span class="literal">True</span>,</span><br><span class="line">                   transform=transforms.Compose([</span><br><span class="line">                       transforms.ToTensor(),</span><br><span class="line">                       <span class="comment"># transforms.Normalize((0.1307,), (0.3081,))</span></span><br><span class="line">                   ])),</span><br><span class="line">    batch_size=batch_size, shuffle=<span class="literal">True</span>)</span><br><span class="line">test_loader = torch.utils.data.DataLoader(</span><br><span class="line">    datasets.MNIST(<span class="string">&#x27;./mnist data/&#x27;</span>, train=<span class="literal">False</span>, transform=transforms.Compose([</span><br><span class="line">        transforms.ToTensor(),</span><br><span class="line">        <span class="comment"># transforms.Normalize((0.1307,), (0.3081,))</span></span><br><span class="line">    ])),</span><br><span class="line">    batch_size=batch_size, shuffle=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MLP</span>(nn.Module):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(MLP, self).__init__()</span><br><span class="line"></span><br><span class="line">        self.model = nn.Sequential(</span><br><span class="line">            nn.Linear(<span class="number">784</span>, <span class="number">200</span>),</span><br><span class="line">            nn.LeakyReLU(inplace=<span class="literal">True</span>),</span><br><span class="line">            nn.Linear(<span class="number">200</span>, <span class="number">200</span>),</span><br><span class="line">            nn.LeakyReLU(inplace=<span class="literal">True</span>),</span><br><span class="line">            nn.Linear(<span class="number">200</span>, <span class="number">10</span>),</span><br><span class="line">            nn.LeakyReLU(inplace=<span class="literal">True</span>),</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        x = self.model(x)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">device = torch.device(<span class="string">&#x27;cuda:0&#x27;</span>)</span><br><span class="line">net = MLP().to(device)</span><br><span class="line">optimizer = optim.SGD(net.parameters(), lr=learning_rate)</span><br><span class="line">criteon = nn.CrossEntropyLoss().to(device)</span><br><span class="line"></span><br><span class="line">viz = Visdom()</span><br><span class="line"></span><br><span class="line">viz.line([<span class="number">0.</span>], [<span class="number">0.</span>], win=<span class="string">&#x27;train_loss&#x27;</span>, opts=<span class="built_in">dict</span>(title=<span class="string">&#x27;train loss&#x27;</span>))</span><br><span class="line">viz.line([[<span class="number">0.0</span>, <span class="number">0.0</span>]], [<span class="number">0.</span>], win=<span class="string">&#x27;test&#x27;</span>, opts=<span class="built_in">dict</span>(title=<span class="string">&#x27;test loss&amp;acc.&#x27;</span>,</span><br><span class="line">                                                   legend=[<span class="string">&#x27;loss&#x27;</span>, <span class="string">&#x27;acc.&#x27;</span>]))</span><br><span class="line">global_step = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(epochs):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> batch_idx, (data, target) <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_loader):</span><br><span class="line">        data = data.view(-<span class="number">1</span>, <span class="number">28</span>*<span class="number">28</span>)</span><br><span class="line">        data, target = data.to(device), target.to(device)</span><br><span class="line"></span><br><span class="line">        logits = net(data)</span><br><span class="line">        loss = criteon(logits, target)</span><br><span class="line"></span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        loss.backward()</span><br><span class="line">        <span class="comment"># print(w1.grad.norm(), w2.grad.norm())</span></span><br><span class="line">        optimizer.step()</span><br><span class="line"></span><br><span class="line">        global_step += <span class="number">1</span></span><br><span class="line">        viz.line([loss.item()], [global_step], win=<span class="string">&#x27;train_loss&#x27;</span>, update=<span class="string">&#x27;append&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> batch_idx % <span class="number">100</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Train Epoch: &#123;&#125; [&#123;&#125;/&#123;&#125; (&#123;:.0f&#125;%)]\tLoss: &#123;:.6f&#125;&#x27;</span>.<span class="built_in">format</span>(</span><br><span class="line">                epoch, batch_idx * <span class="built_in">len</span>(data), <span class="built_in">len</span>(train_loader.dataset),</span><br><span class="line">                       <span class="number">100.</span> * batch_idx / <span class="built_in">len</span>(train_loader), loss.item()))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    test_loss = <span class="number">0</span></span><br><span class="line">    correct = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> data, target <span class="keyword">in</span> test_loader:</span><br><span class="line">        data = data.view(-<span class="number">1</span>, <span class="number">28</span> * <span class="number">28</span>)</span><br><span class="line">        data, target = data.to(device), target.cuda()</span><br><span class="line">        logits = net(data)</span><br><span class="line">        test_loss += criteon(logits, target).item()</span><br><span class="line"></span><br><span class="line">        pred = logits.argmax(dim=<span class="number">1</span>)</span><br><span class="line">        correct += pred.eq(target).<span class="built_in">float</span>().<span class="built_in">sum</span>().item()</span><br><span class="line"></span><br><span class="line">    viz.line([[test_loss, correct / <span class="built_in">len</span>(test_loader.dataset)]],</span><br><span class="line">             [global_step], win=<span class="string">&#x27;test&#x27;</span>, update=<span class="string">&#x27;append&#x27;</span>)</span><br><span class="line">    viz.images(data.view(-<span class="number">1</span>, <span class="number">1</span>, <span class="number">28</span>, <span class="number">28</span>), win=<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">    viz.text(<span class="built_in">str</span>(pred.detach().cpu().numpy()), win=<span class="string">&#x27;pred&#x27;</span>,</span><br><span class="line">             opts=<span class="built_in">dict</span>(title=<span class="string">&#x27;pred&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    test_loss /= <span class="built_in">len</span>(test_loader.dataset)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;\nTest set: Average loss: &#123;:.4f&#125;, Accuracy: &#123;&#125;/&#123;&#125; (&#123;:.0f&#125;%)\n&#x27;</span>.<span class="built_in">format</span>(</span><br><span class="line">        test_loss, correct, <span class="built_in">len</span>(test_loader.dataset),</span><br><span class="line">        <span class="number">100.</span> * correct / <span class="built_in">len</span>(test_loader.dataset)))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>视图</li>
</ul>
<p>​        <img src="/posts/f19419c5/image-20221124201948485.png" alt="image-20221124201948485"></p>
<h2 id="端口占用处理"><a href="#端口占用处理" class="headerlink" title="端口占用处理"></a>端口占用处理</h2><p>windows上</p>
<ul>
<li>查找本端口当前使用情况</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">netstat -ano |findstr &quot;8097&quot;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TCP    0.0.0.0:8097           0.0.0.0:0              LISTENING       12236</span><br><span class="line">  TCP    [::]:8097              [::]:0                 LISTENING       12236</span><br></pre></td></tr></table></figure>
<ul>
<li>查询当前端口PID的进程，前一步看到为12236</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tasklist | findstr 12236</span><br></pre></td></tr></table></figure>
<ul>
<li>终止进程</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">taskkill /f /t /im &quot;12236&quot;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">成功: 已终止 PID 12236 (属于 PID 7560 子进程)的进程。</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>图基本知识</title>
    <url>/posts/5f3db67/</url>
    <content><![CDATA[<h1 id="图的表示"><a href="#图的表示" class="headerlink" title="图的表示"></a>图的表示</h1><p>点和边构成的数据结构</p>
<p>日常生活中无处不在：图像：像素和像素之间的连接构成的图; 网页： 网页之间的跳转;</p>
<span id="more"></span>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p><strong>无向图和有向图</strong></p>
<h2 id="表示"><a href="#表示" class="headerlink" title="表示"></a>表示</h2><ul>
<li>邻接矩阵</li>
</ul>
<h1 id="图的性质"><a href="#图的性质" class="headerlink" title="图的性质"></a>图的性质</h1><h2 id="度"><a href="#度" class="headerlink" title="度"></a>度</h2><ul>
<li>无向图的度==该节点连接的边的数量</li>
<li>有向图的度<ul>
<li>出度：从该节点指向的边的数量</li>
<li>入度：指向该节点的边的数量</li>
</ul>
</li>
</ul>
<h2 id="子图"><a href="#子图" class="headerlink" title="子图"></a>子图</h2><p>​    子图所有的节点都包含在大图里面；</p>
<p>​    子图的边都是大图的边的子集；</p>
<h2 id="连通图和连通分量"><a href="#连通图和连通分量" class="headerlink" title="连通图和连通分量"></a>连通图和连通分量</h2><p>无向图</p>
<ul>
<li><p>连通图：</p>
<p>任意节点i能够通过一些边到达节点j，则称之为连通图；反之非连通图。</p>
<p>对于一个无向图：没有孤立的节点其实都能连通</p>
</li>
<li><p>连通分量：<br>无向图G的一个极大连通子图称为G的一个连通分量（或连通分支）。</p>
<p>连通图只有一个连通分量：他本身；非连通图有多个连通分量。</p>
</li>
</ul>
<p>有向图的连通性</p>
<ul>
<li>强连通图：给定图G的任意两个结点u,v可互相到达。</li>
<li>弱连通图：至少有一对结点不满足单向连通，但去掉边的方向之后从无向图的观点看是连通图。</li>
</ul>
<h2 id="最短路径和图直径"><a href="#最短路径和图直径" class="headerlink" title="最短路径和图直径"></a>最短路径和图直径</h2><p>两结点的最短到达路径就是最短路径</p>
<p>两两结点的最短路径中的长度最大值是图直径。</p>
<h2 id="度中心性"><a href="#度中心性" class="headerlink" title="度中心性"></a>度中心性</h2><script type="math/tex; mode=display">
度中心性 = \frac{N_{degree}}{n-1}</script><p>$N_{degree}$表示该节点的度，n为该节点所在图的节点总数。</p>
<h2 id="特征向量中心性Eigenvector-Centrality"><a href="#特征向量中心性Eigenvector-Centrality" class="headerlink" title="特征向量中心性Eigenvector Centrality"></a>特征向量中心性Eigenvector Centrality</h2><p>最大特征值对应的特征向量作为特征向量中心性的对比指标。</p>
<p>A为邻接矩阵；</p>
<p>如图，最大的特征值是第一个，所以特征向量对应第一列。</p>
<p>（特征向量中心性将特征向量的负值变成正进行统一对比）</p>
<p><img src="/posts/5f3db67/image-20221126140426649.png" style="zoom: 67%;"></p>
<p>特征向量中心性不仅考虑了自己节点的度，还考虑了和他向量节点的度的情况。如v4的值会比v2和v3大是因为它虽然度和v2\v3一样大，但是相连的是v1和v5，比v2/v3向量的节点的度总体要大。</p>
<p><strong>conclu:特征向量中心性比度中心性可以更好的表示节点在图中所处的位置。</strong></p>
<h2 id="中介中心性-Betweenness-Centrality"><a href="#中介中心性-Betweenness-Centrality" class="headerlink" title="中介中心性 Betweenness Centrality"></a>中介中心性 Betweenness Centrality</h2><script type="math/tex; mode=display">
Betweenness  = \frac{经过该节点的最短路径}{其余两两节点的最短路径}</script><h2 id="连接中心性-Closeness"><a href="#连接中心性-Closeness" class="headerlink" title="连接中心性 Closeness"></a>连接中心性 Closeness</h2><script type="math/tex; mode=display">
Closeness = \frac{n-1}{该节点到其他节点最短路径之和}</script><p>​    n为节点总数；</p>
<h2 id="网页排序算法"><a href="#网页排序算法" class="headerlink" title="网页排序算法"></a>网页排序算法</h2><h3 id="pagerank"><a href="#pagerank" class="headerlink" title="pagerank"></a>pagerank</h3><p>边的pagerank值为节点向外指向时平分的结果。如节点2向外指向的边有两条，因此现在那两条边的pagerank值都为pagerank2/2。</p>
<p>节点的pagerank值即为指向它的边的值的和。</p>
<p><img src="/posts/5f3db67/image-20221126142317310.png" style="zoom:67%;"></p>
<p>不断的迭代，最后每个节点的pagerank值达到稳态    。</p>
<p>阻尼系数：如节点3到节点4的概率有0.15。</p>
<h3 id="HITS"><a href="#HITS" class="headerlink" title="HITS"></a>HITS</h3><p><img src="/posts/5f3db67/image-20221126142814847.png" style="zoom: 67%;"></p>
<p>每个节点都有authority值和hub值</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> networkx <span class="keyword">as</span> nx</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">lis =<span class="keyword">lambda</span> x:random.randint(<span class="number">1</span>,<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">edges  = pd.DataFrame()</span><br><span class="line">edges[<span class="string">&#x27;sources&#x27;</span>] = [lis(x) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">12</span>)]</span><br><span class="line">edges[<span class="string">&#x27;targets&#x27;</span>] = [lis(x) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">12</span>)]</span><br><span class="line">edges[<span class="string">&#x27;weights&#x27;</span>] = [<span class="number">1</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">12</span>)]</span><br><span class="line"></span><br><span class="line">G = nx.from_pandas_edgelist(edges,source=<span class="string">&#x27;sources&#x27;</span>,target=<span class="string">&#x27;targets&#x27;</span>,edge_attr=<span class="string">&#x27;weights&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;G:&quot;</span>,G)</span><br><span class="line"><span class="built_in">print</span>(nx.__version__)</span><br><span class="line"><span class="built_in">print</span>(nx.adjacency_matrix(G))</span><br><span class="line"><span class="comment">#度</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;degree:&quot;</span>,nx.degree(G))</span><br><span class="line"><span class="comment"># 连通分量</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;connected_components&quot;</span>,<span class="built_in">list</span>(nx.connected_components(G)))</span><br><span class="line"><span class="comment">#图直径</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;diameter:&quot;</span>,nx.diameter(G))</span><br><span class="line"><span class="comment"># 度中心性</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;degree_centrality:&quot;</span>,nx.degree_centrality(G))</span><br><span class="line"><span class="comment">#特征向量中心性</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;eigenvector:&quot;</span>,nx.eigenvector_centrality(G))</span><br><span class="line"><span class="comment"># betweenness 中介中心性</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;betweenness:&quot;</span>,nx.betweenness_centrality(G))</span><br><span class="line"><span class="comment"># closeness 连接中心性</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;closenesss:&quot;</span>,nx.closeness_centrality(G))</span><br><span class="line"><span class="comment">#pagerank</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;pagerank:&quot;</span>,nx.pagerank(G))</span><br><span class="line"><span class="comment">#hits</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hits:&quot;</span>,nx.hits(G))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FutureWarning: adjacency_matrix will return a scipy.sparse array instead of a matrix in Networkx 3.0.</span><br><span class="line">  print(nx.adjacency_matrix(G))</span><br><span class="line">G: Graph with 6 nodes and 8 edges</span><br><span class="line">2.8.4</span><br><span class="line">  (0, 0)	1</span><br><span class="line">  (0, 2)	1</span><br><span class="line">  (0, 3)	1</span><br><span class="line">  (0, 4)	1</span><br><span class="line">  (1, 1)	1</span><br><span class="line">  (1, 4)	1</span><br><span class="line">  (1, 5)	1</span><br><span class="line">  (2, 0)	1</span><br><span class="line">  (2, 3)	1</span><br><span class="line">  (3, 0)	1</span><br><span class="line">  (3, 2)	1</span><br><span class="line">  (4, 0)	1</span><br><span class="line">  (4, 1)	1</span><br><span class="line">  (5, 1)	1</span><br><span class="line">degree: [(3, 5), (1, 4), (4, 2), (2, 2), (5, 2), (6, 1)]</span><br><span class="line">connected_components [&#123;1, 2, 3, 4, 5, 6&#125;]</span><br><span class="line">diameter: 4</span><br><span class="line">degree_centrality: &#123;3: 1.0, 1: 0.8, 4: 0.4, 2: 0.4, 5: 0.4, 6: 0.2&#125;</span><br><span class="line">eigenvector: &#123;3: 0.6845438993664699, 1: 0.2664667519552274, 4: 0.4038050904760662, 2: 0.4038050904760662, 5: 0.3528502881437044, 6: 0.09886704157967073&#125;</span><br><span class="line">betweenness: &#123;3: 0.6000000000000001, 1: 0.4, 4: 0.0, 2: 0.0, 5: 0.6000000000000001, 6: 0.0&#125;</span><br><span class="line">closenesss: &#123;3: 0.625, 1: 0.5, 4: 0.45454545454545453, 2: 0.45454545454545453, 5: 0.625, 6: 0.35714285714285715&#125;</span><br><span class="line">pagerank: &#123;3: 0.26059842893288254, 1: 0.22624644367910318, 4: 0.1397855189975688, 2: 0.1397855189975688, 5: 0.1444805278346477, 6: 0.08910356155822868&#125;</span><br><span class="line">hits: (&#123;3: 0.3097026575730737, 1: 0.1205522404859372, 4: 0.18269069072963665, 2: 0.18269069072963665, 5: 0.1596357156065535, 6: 0.04472800487516233&#125;, &#123;3: 0.30970265757307375, 1: 0.1205522404859372, 4: 0.1826906907296366, 2: 0.18269069072963656, 5: 0.1596357156065534, 6: 0.04472800487516234&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>视频来源：<a href="https://www.bilibili.com/video/BV1aB4y1Q7RL">https://www.bilibili.com/video/BV1aB4y1Q7RL</a></p>
]]></content>
      <categories>
        <category>图神经网络</category>
      </categories>
      <tags>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>第一次搭建hexo博客</title>
    <url>/posts/83682157/</url>
    <content><![CDATA[<h2 id="hexo-deploy-到github失败"><a href="#hexo-deploy-到github失败" class="headerlink" title="hexo deploy 到github失败"></a>hexo deploy 到github失败</h2><p>使用deploy之后要求输入账户和密码，密码正确但是显示验证失败。</p>
<span id="more"></span>
<ul>
<li><p>失败原因：</p>
<p>github 21年取消了密码验证</p>
<p><img src="/posts/83682157/image-20221117162546351.png" alt></p>
</li>
</ul>
<ul>
<li><p>解决方式</p>
<p>在_config.yml的deploy中，repo对应的填写为github仓库的ssh地址，可以避免进行密码验证（前提：git配置完成，github上有设置公钥）</p>
</li>
</ul>
<h2 id="完成的配置"><a href="#完成的配置" class="headerlink" title="完成的配置"></a>完成的配置</h2><ul>
<li><p>使用hexo主题</p>
<p><a href="https://github.com/probberechts/hexo-theme-cactus">hexo-theme-cactus</a></p>
<ul>
<li><a href="https://github.com/theme-next/hexo-theme-next">theme-next/hexo-theme-next: Elegant and powerful theme for Hexo. (github.com)</a></li>
</ul>
</li>
<li><p>主题配置 tags 和 categories</p>
</li>
<li><p>配置baidu_analytics</p>
</li>
<li><p>comment</p>
<ul>
<li>使用utterances设置comment</li>
<li>来必力</li>
</ul>
</li>
<li><p>不蒜子统计</p>
</li>
<li><p>使用主题的search</p>
<ul>
<li>不成功-&gt;解决：发现是npm install的时候没有在博客根目录导致的问题</li>
</ul>
</li>
<li><p>解决图片路径问题</p>
<ul>
<li><p>sources/images目录下存引图片</p>
</li>
<li><p>setup那篇post使用post_asset_folder: true的方式（需要安装hexo插件），将资源放在对应目录下</p>
<ul>
<li><p>本地成功但是服务器显示无效，重新安装插件成功：</p>
<p><code>npm install https://github.com/7ym0n/hexo-asset-image --save</code></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>hexo new post失败</p>
<ul>
<li>使用 hexo new ‘[post]’ “postname”</li>
</ul>
</li>
<li><p>数学公式渲染</p>
<ul>
<li><a href="https://blog.csdn.net/qq_38496329/article/details/104065659">https://blog.csdn.net/qq_38496329/article/details/104065659</a></li>
<li>注意在文章中front 部分设置mathjax: true</li>
</ul>
</li>
</ul>
<h3 id="音乐"><a href="#音乐" class="headerlink" title="音乐"></a>音乐</h3><ul>
<li><strong>获取网易云外链的iframe代码</strong></li>
</ul>
<p>打开网易云<a href="https://music.163.com/">官网</a>，选择喜欢的歌单或者歌曲，可以自己创建歌单。</p>
<p>限制：有些歌曲有版权保护，无法生成外链</p>
<p><img src="\第一次搭建hexo博客\image-20221125133318434.png" alt="image-20221125133318434" style="zoom:50%;"></p>
<p><img src="\第一次搭建hexo博客\image-20221125133225148.png" alt="image-20221125133225148" style="zoom: 50%;"></p>
<p>[博客根目录]\themes\next\layout_macro\sidebar.swig，在class为siderbar-inner的div内添加iframe</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% macro render(display_toc) %&#125;</span><br><span class="line">  &lt;div class=&quot;toggle sidebar-toggle&quot;&gt;</span><br><span class="line">    &lt;span class=&quot;toggle-line toggle-line-first&quot;&gt;&lt;/span&gt;</span><br><span class="line">    &lt;span class=&quot;toggle-line toggle-line-middle&quot;&gt;&lt;/span&gt;</span><br><span class="line">    &lt;span class=&quot;toggle-line toggle-line-last&quot;&gt;&lt;/span&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">  &lt;aside class=&quot;sidebar&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;sidebar-inner&quot;&gt;</span><br></pre></td></tr></table></figure>
<h3 id="图标"><a href="#图标" class="headerlink" title="图标"></a>图标</h3><p>【next主题下】</p>
<ul>
<li>免费图标下载网站：</li>
</ul>
<p><a href="https://icons8.com/">https://icons8.com/</a></p>
<p><a href="https://findicons.com/icon/558960/cursor">Cursor icon PNG, ICO or ICNS | Free vector icons (findicons.com)</a></p>
<ul>
<li>站点图标</li>
</ul>
<p>next主题默认是黑色的N</p>
<p>修改： next主题的配置文件中有一项配置 favicon，将配置下的图片目录更改为想换的图片即可</p>
<ul>
<li><p>鼠标烟花特效</p>
<p><a href="https://siriusq.top/Next升级-Mac迁移.html#鼠标点击特效">Next 升级 + Mac 迁移 | Sirius (siriusq.top)</a></p>
</li>
</ul>
<p>​                注意将主题配置文件中将body-end.swig对应的部分移除注释</p>
<ul>
<li><p>鼠标样式修改</p>
<p>hexo\source_data\styles.styl中添加</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">// 鼠标样式</span><br><span class="line">  * &#123;</span><br><span class="line">      <span class="attribute">cursor</span>: <span class="built_in">url</span>(<span class="string">&quot;image url&quot;</span>),auto<span class="meta">!important</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-pseudo">:active</span> &#123;</span><br><span class="line">      <span class="attribute">cursor</span>: <span class="built_in">url</span>(<span class="string">&quot;image url&quot;</span>),auto<span class="meta">!important</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意主题配置文件中custom_file_path: style: source/_data/styles.styl移除注释</p>
</li>
</ul>
]]></content>
      <categories>
        <category>hexo配置</category>
      </categories>
  </entry>
  <entry>
    <title>【pytorch-learning】(二) 模型搭建-训练-测试</title>
    <url>/posts/13fc6476/</url>
    <content><![CDATA[<h1 id="模型搭建"><a href="#模型搭建" class="headerlink" title="模型搭建"></a>模型搭建</h1><h2 id="自定义模型"><a href="#自定义模型" class="headerlink" title="自定义模型"></a>自定义模型</h2><p>基本骨架为 <code>torch.nn.Module</code></p>
<span id="more"></span>
<p>实现一个继承自Module的类，该类中主要包含init和forward方法。</p>
<p>通过forward方法完成网络的前向传递。</p>
<p>详细讲解见我记的B站小土堆的笔记：<a href="https://github.com/Xandra298/Pytorchlearning/blob/master/小土堆/1.2pytorch使用_神经网络搭建.ipynb">神经网络搭建</a></p>
<p>一个简单的代码示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span>  nn</span><br><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> Conv2d</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line"></span><br><span class="line">dataset = torchvision.datasets.CIFAR10(<span class="string">&quot;dataset/&quot;</span>,train=<span class="literal">False</span>,transform=torchvision.transforms.ToTensor(),download= <span class="literal">True</span>)</span><br><span class="line">dataloader  = DataLoader(dataset,batch_size=<span class="number">64</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Model_conv</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(Model_conv, self).__init__()</span><br><span class="line">        self.conv1 = Conv2d(in_channels=<span class="number">3</span>,out_channels=<span class="number">3</span>,kernel_size=<span class="number">3</span>,stride=<span class="number">1</span>,padding=<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self,x</span>):</span><br><span class="line">        x = self.conv1(x)</span><br><span class="line">        <span class="keyword">return</span>  x</span><br><span class="line"></span><br><span class="line">model = Model_conv()</span><br><span class="line"><span class="built_in">print</span>(model)</span><br><span class="line"><span class="keyword">for</span> data <span class="keyword">in</span> dataloader:</span><br><span class="line">    imgs,target = data</span><br><span class="line">    <span class="built_in">print</span>(imgs.shape)</span><br><span class="line">    output = model(imgs)</span><br><span class="line">    <span class="built_in">print</span>(output.shape)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>torch.nn.Sequential</code>使用示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> Conv2d, MaxPool2d, Linear, Sequential</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Model</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(Model, self).__init__()</span><br><span class="line">        self.model1 = Sequential(</span><br><span class="line">            Conv2d(<span class="number">3</span>, <span class="number">32</span>, kernel_size=<span class="number">5</span>, padding=<span class="number">2</span>),</span><br><span class="line">            MaxPool2d(<span class="number">2</span>),</span><br><span class="line">            Conv2d(<span class="number">32</span>, <span class="number">32</span>, <span class="number">5</span>, padding=<span class="number">2</span>),</span><br><span class="line">            MaxPool2d(<span class="number">2</span>),</span><br><span class="line">            Conv2d(<span class="number">32</span>, <span class="number">64</span>, <span class="number">5</span>, padding=<span class="number">2</span>),</span><br><span class="line">            MaxPool2d(<span class="number">2</span>),</span><br><span class="line">            nn.Flatten(),</span><br><span class="line">            Linear(<span class="number">1024</span>, <span class="number">64</span>),</span><br><span class="line">            Linear(<span class="number">64</span>, <span class="number">10</span>)</span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self,x</span>):</span><br><span class="line">        x = self.model1(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">model = Model()</span><br></pre></td></tr></table></figure>
<h2 id="迁移学习"><a href="#迁移学习" class="headerlink" title="迁移学习"></a>迁移学习</h2><p>修改已有网络模型用于自己的任务</p>
<h3 id="实例一：将VGG16用于数据集CIFAR10的分类"><a href="#实例一：将VGG16用于数据集CIFAR10的分类" class="headerlink" title="实例一：将VGG16用于数据集CIFAR10的分类"></a>实例一：将VGG16用于数据集CIFAR10的分类</h3><p>VGG16<a href="https://pytorch.org/vision/0.9/models.html">模型</a> 的dataset是<a href="https://pytorch.org/vision/0.8/datasets.html#imagenet">ImagNet</a></p>
<p>通过torchvision.models.vgg16(pretained=True)(pretained=True会将其权重也下载下来）将模型下载下来之后，默认保存路径是<code>C:\Users\[usename].cache\torch\hub\checkpoints</code></p>
<p>VGG16用于1000分类（最后全连接层的输出是1000），使用数据集CIFAR10是需要10分类的。因此难点在于如何使用该VGG模型进行迁移。 下文代码展现了两种主要方式</p>
<h4 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>  torchvision</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span>  nn</span><br><span class="line"><span class="comment"># vgg16_false = torchvision.models.vgg16(pretrained=False)</span></span><br><span class="line">vgg16_true = torchvision.models.vgg16(pretrained=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">train_data = torchvision.datasets.CIFAR10(<span class="string">&quot;dataset&quot;</span>,train=<span class="literal">True</span>,transform=torchvision.transforms.ToTensor(),download=<span class="literal">True</span>)</span><br><span class="line"><span class="comment">##traindata是10分类，而vgg16是1000分类</span></span><br><span class="line"></span><br><span class="line">vgg16_true.add_module(<span class="string">&#x27;add_linear&#x27;</span>,nn.Linear(<span class="number">1000</span>,<span class="number">10</span>))</span><br><span class="line"><span class="built_in">print</span>(vgg16_true)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>VGG模型添加了一层之后的结构</p>
<p>多了一层添加的：</p>
<p><code>(add_linear): Linear(in_features=1000, out_features=10, bias=True)</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">VGG(</span><br><span class="line">  (features): Sequential(</span><br><span class="line">    (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))</span><br><span class="line">    (1): ReLU(inplace=True)</span><br><span class="line">    (2): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))</span><br><span class="line">    (3): ReLU(inplace=True)</span><br><span class="line">    (4): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)</span><br><span class="line">    (5): Conv2d(64, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))</span><br><span class="line">    (6): ReLU(inplace=True)</span><br><span class="line">    (7): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))</span><br><span class="line">    (8): ReLU(inplace=True)</span><br><span class="line">    (9): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)</span><br><span class="line">    (10): Conv2d(128, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))</span><br><span class="line">    (11): ReLU(inplace=True)</span><br><span class="line">    (12): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))</span><br><span class="line">    (13): ReLU(inplace=True)</span><br><span class="line">    (14): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))</span><br><span class="line">    (15): ReLU(inplace=True)</span><br><span class="line">    (16): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)</span><br><span class="line">    (17): Conv2d(256, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))</span><br><span class="line">    (18): ReLU(inplace=True)</span><br><span class="line">    (19): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))</span><br><span class="line">    (20): ReLU(inplace=True)</span><br><span class="line">    (21): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))</span><br><span class="line">    (22): ReLU(inplace=True)</span><br><span class="line">    (23): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)</span><br><span class="line">    (24): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))</span><br><span class="line">    (25): ReLU(inplace=True)</span><br><span class="line">    (26): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))</span><br><span class="line">    (27): ReLU(inplace=True)</span><br><span class="line">    (28): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))</span><br><span class="line">    (29): ReLU(inplace=True)</span><br><span class="line">    (30): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)</span><br><span class="line">  )</span><br><span class="line">  (avgpool): AdaptiveAvgPool2d(output_size=(7, 7))</span><br><span class="line">  (classifier): Sequential(</span><br><span class="line">    (0): Linear(in_features=25088, out_features=4096, bias=True)</span><br><span class="line">    (1): ReLU(inplace=True)</span><br><span class="line">    (2): Dropout(p=0.5, inplace=False)</span><br><span class="line">    (3): Linear(in_features=4096, out_features=4096, bias=True)</span><br><span class="line">    (4): ReLU(inplace=True)</span><br><span class="line">    (5): Dropout(p=0.5, inplace=False)</span><br><span class="line">    (6): Linear(in_features=4096, out_features=1000, bias=True)</span><br><span class="line">  )</span><br><span class="line">  (add_linear): Linear(in_features=1000, out_features=10, bias=True)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h4 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h4><p>想要加到其中的classifier里面</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">vgg16_true.classifier.add_module(<span class="string">&#x27;add_linear&#x27;</span>,nn.Linear(<span class="number">1000</span>,<span class="number">10</span>))</span><br></pre></td></tr></table></figure>
<h3 id="实例二：resnet18"><a href="#实例二：resnet18" class="headerlink" title="实例二：resnet18"></a>实例二：resnet18</h3><p>获取网络中的模型，通过Sequential完成新模型的组建</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torchvision.models <span class="keyword">import</span> resnet18 <span class="comment">##从网络获取模型</span></span><br><span class="line">trained_model = resnet18(pretrained=<span class="literal">True</span>)</span><br><span class="line">                <span class="comment">#*用于迭代取出list中的内容</span></span><br><span class="line">model = nn.Sequential(*<span class="built_in">list</span>(trained_model.children())[:-<span class="number">1</span>],<span class="comment">#[b,512,1,1]</span></span><br><span class="line">                          nn.Flatten(),<span class="comment">#[b,512,1,1]=&gt;[b,512]</span></span><br><span class="line">                          nn.Linear(<span class="number">512</span>,<span class="number">5</span>)</span><br><span class="line">                          ).to(device)</span><br></pre></td></tr></table></figure>
<h1 id="模型保存和读取"><a href="#模型保存和读取" class="headerlink" title="模型保存和读取"></a>模型保存和读取</h1><h2 id="方式一-1"><a href="#方式一-1" class="headerlink" title="方式一"></a>方式一</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>  torchvision</span><br><span class="line"><span class="keyword">import</span>  torch</span><br><span class="line"></span><br><span class="line"><span class="comment">#模型</span></span><br><span class="line">vgg16 = torchvision.models.vgg16(pretrained=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ##保存方式1 模型结构+模型参数</span></span><br><span class="line"><span class="comment"># ### 参数：模型，路径</span></span><br><span class="line"></span><br><span class="line">torch.save(vgg16,<span class="string">&quot;vgg16_modelsave_1.pth&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">###读取方式1&gt;&gt;保存方式1</span></span><br><span class="line"><span class="comment">##参数：路径</span></span><br><span class="line">model = torch.load(<span class="string">&quot;vgg16_modelsave_1.pth&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(model)</span><br></pre></td></tr></table></figure>
<h2 id="方式二（推荐）"><a href="#方式二（推荐）" class="headerlink" title="方式二（推荐）"></a>方式二（推荐）</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>  torchvision</span><br><span class="line"><span class="keyword">import</span>  torch</span><br><span class="line"></span><br><span class="line"><span class="comment">#模型</span></span><br><span class="line">vgg16 = torchvision.models.vgg16(pretrained=<span class="literal">False</span>)</span><br><span class="line"><span class="comment">#保存方式2 模型参数（官方推荐）</span></span><br><span class="line"><span class="comment">##参数：模型.state_dict(),路径</span></span><br><span class="line"><span class="comment">##527M</span></span><br><span class="line">torch.save(vgg16.state_dict(),<span class="string">&quot;vgg16_modelsave_2.pth&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">##读取方式2&gt;&gt;保存方式2</span></span><br><span class="line">vgg16 = torchvision.models.vgg16(pretrained=<span class="literal">False</span>)</span><br><span class="line">vgg16.load_state_dict(torch.load(<span class="string">&quot;vgg16_modelsave_2.pth&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(vgg16)</span><br></pre></td></tr></table></figure>
<h2 id="方式一的报错实例"><a href="#方式一的报错实例" class="headerlink" title="方式一的报错实例"></a>方式一的报错实例</h2><p>报错过程：</p>
<ol>
<li><p>a.py中创建模型，并使用toch.save(model,”model path”)</p>
</li>
<li><p>b.py中加载该模型：model = torch.load(“model path”)</p>
</li>
</ol>
<p>解决方案：要让该文件能访问到该模型的定义。</p>
<ul>
<li><p>在直接加载前重新定义一下该模型</p>
</li>
<li><p>或者 <code>from model_save import *</code> 即在头文件import一下该模型定义文件</p>
</li>
</ul>
<h1 id="模型训练"><a href="#模型训练" class="headerlink" title="模型训练"></a>模型训练</h1><h2 id="随机梯度下降"><a href="#随机梯度下降" class="headerlink" title="随机梯度下降"></a>随机梯度下降</h2><p><a href="https://github.com/Xandra298/Pytorchlearning/blob/master/4.随机梯度下降.ipynb">详细理论</a>)</p>
<h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><p>通过损失函数计算经过训练的模型其预测结果与真实值的误差，loss越小说明二者越接近。</p>
<p>通过梯度下降搜索极值点。计算loss，通过loss.backward()反向传播进行自动求导获得梯度。</p>
<p>对于模型而言，变化的是各个权重参数w。</p>
<p><a href="https://pytorch.org/docs/1.8.1/generated/torch.nn.CrossEntropyLoss.html#torch.nn.CrossEntropyLoss">CrossEntropyLoss</a></p>
<p>使用实例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>  torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span>  nn</span><br><span class="line">x = torch.tensor([<span class="number">0.1</span>,<span class="number">0.8</span>,<span class="number">0.1</span>])</span><br><span class="line">y = torch.tensor([<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">x = x.reshape(<span class="number">1</span>,<span class="number">3</span>)</span><br><span class="line">loss_cross = nn.CrossEntropyLoss()</span><br><span class="line">result_cross = loss_cross(x,y)</span><br><span class="line"><span class="built_in">print</span>(result_cross)</span><br></pre></td></tr></table></figure>
<h3 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h3><p>决定梯度下降的方式。</p>
<p>使用主要关联四行代码：</p>
<ul>
<li><code>optim = torch.optim.SGD(model.parameters(),lr=0.01)</code>  （SGD为一种优化器）</li>
</ul>
<p>epoch 内</p>
<ul>
<li><code>optim.zero_grad()</code> ##将优化器梯度清零，每一次循环注意清零</li>
<li><code>result_loss.backward()</code></li>
<li><code>optim.step()</code></li>
</ul>
<h2 id="训练模型"><a href="#训练模型" class="headerlink" title="训练模型"></a>训练模型</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(epoch):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;----epoch &#123;&#125; starting----&quot;</span>.<span class="built_in">format</span>(i))</span><br><span class="line">    model.train()</span><br><span class="line">    <span class="comment">##训练步骤开始</span></span><br><span class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> train_dataloader:</span><br><span class="line">        imgs,targets = data</span><br><span class="line">        outputs = model(imgs)</span><br><span class="line">        loss = loss_fn(outputs,targets)</span><br><span class="line"></span><br><span class="line">        <span class="comment">##优化器优化模型</span></span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line"></span><br><span class="line">        total_train_step+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> total_train_step % <span class="number">100</span> == <span class="number">0</span>:</span><br><span class="line">           <span class="built_in">print</span>(<span class="string">&quot;batch &#123;&#125;---loss:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(total_train_step,loss.item()))</span><br><span class="line">        </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="模型测试评估"><a href="#模型测试评估" class="headerlink" title="模型测试评估"></a>模型测试评估</h1><p>将测试集传入训练好的模型得到预测输出。</p>
<p>将预测输出和测试集的label进行比较以评估该模型。</p>
<p>有标签的评估指标有：</p>
<ul>
<li>准确率</li>
<li>召回率</li>
<li>精确率</li>
<li>F1-score</li>
<li>…</li>
</ul>
<p>另外，如ROC曲线，AUC，AP等也是常见的评估</p>
<h1 id="自定义数据集实战"><a href="#自定义数据集实战" class="headerlink" title="自定义数据集实战"></a>自定义数据集实战</h1><h2 id="数据预处理与加载"><a href="#数据预处理与加载" class="headerlink" title="数据预处理与加载"></a>数据预处理与加载</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:UTF-8 -*-</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> os,glob</span><br><span class="line"><span class="keyword">import</span> random,csv</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset,DataLoader</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pokemen</span>(<span class="title class_ inherited__">Dataset</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,root,resize,mode</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :param root: 数据集根目录；</span></span><br><span class="line"><span class="string">                    这次的存储形式是根目录下有文件夹，每个文件夹下是数据集图片，文件夹名称是对应的类别</span></span><br><span class="line"><span class="string">        :param resize:</span></span><br><span class="line"><span class="string">        :param mode: train\test\val</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="built_in">super</span>(Pokemen, self).__init__()</span><br><span class="line">        self.root = root</span><br><span class="line">        self.resize = resize</span><br><span class="line"></span><br><span class="line">        self.name2label = &#123;&#125;<span class="comment"># 存储name对应编码的字典</span></span><br><span class="line">        <span class="comment">#遍历根目录下文件夹名称</span></span><br><span class="line">        <span class="keyword">for</span> name <span class="keyword">in</span> <span class="built_in">sorted</span>(os.listdir(os.path.join(root))):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> os.path.isdir(os.path.join(root,name)):</span><br><span class="line">                <span class="comment"># not a dir</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 按照先后顺序获得编码</span></span><br><span class="line">            self.name2label[name] = <span class="built_in">len</span>(self.name2label.keys())</span><br><span class="line">        <span class="built_in">print</span>(self.name2label)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 从csv文件中读取 image_path-label；</span></span><br><span class="line">        <span class="comment"># load_csv方法实现将数据集条目：image_path-label 整理到csv文件中</span></span><br><span class="line">        self.images,self.labels = self.load_csv(<span class="string">&quot;image.csv&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#划分数据集</span></span><br><span class="line">        <span class="keyword">if</span> mode == <span class="string">&#x27;train&#x27;</span>: <span class="comment">#60%</span></span><br><span class="line">            self.images = self.images[:<span class="built_in">int</span>(<span class="number">0.6</span>*<span class="built_in">len</span>(self.images))]</span><br><span class="line">            self.labels = self.labels[:<span class="built_in">int</span>(<span class="number">0.6</span>*<span class="built_in">len</span>(self.labels))]</span><br><span class="line">        <span class="keyword">elif</span> mode == <span class="string">&#x27;val&#x27;</span>: <span class="comment">#20%</span></span><br><span class="line">            self.images = self.images[<span class="built_in">int</span>(<span class="number">0.6</span> * <span class="built_in">len</span>(self.images)):<span class="built_in">int</span>(<span class="number">0.8</span>*<span class="built_in">len</span>(self.images))]</span><br><span class="line">            self.labels = self.labels[<span class="built_in">int</span>(<span class="number">0.6</span> * <span class="built_in">len</span>(self.labels)):<span class="built_in">int</span>(<span class="number">0.8</span>*<span class="built_in">len</span>(self.labels))]</span><br><span class="line">        <span class="keyword">elif</span> mode == <span class="string">&#x27;test&#x27;</span>:</span><br><span class="line">            self.images = self.images[<span class="built_in">int</span>(<span class="number">0.8</span> * <span class="built_in">len</span>(self.images)):]</span><br><span class="line">            self.labels = self.labels[<span class="built_in">int</span>(<span class="number">0.8</span> * <span class="built_in">len</span>(self.labels)):]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">load_csv</span>(<span class="params">self,filename</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        将数据集的image_path-label存储到csv文件中，并从csv文件加载</span></span><br><span class="line"><span class="string">        :param filename: 存储csv的文件路径</span></span><br><span class="line"><span class="string">        :return: images,labels==&gt; images_path,labels</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        savepath = os.path.join(self.root,filename)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(savepath):</span><br><span class="line">            images = []</span><br><span class="line">            <span class="keyword">for</span> name <span class="keyword">in</span> self.name2label.keys():</span><br><span class="line">                <span class="comment">#获取对应文件夹下的图片文件,存储到list(images)内</span></span><br><span class="line">                images += glob.glob(os.path.join(self.root,name,<span class="string">&#x27;*.png&#x27;</span>))</span><br><span class="line">                images += glob.glob(os.path.join(self.root, name, <span class="string">&#x27;*.jpg&#x27;</span>))</span><br><span class="line">                images += glob.glob(os.path.join(self.root, name, <span class="string">&#x27;*.gif&#x27;</span>))</span><br><span class="line">            <span class="comment">#print(images)</span></span><br><span class="line">            <span class="comment">#&#x27;./pokeman/squirtle\\00000073.png&#x27;</span></span><br><span class="line">            random.shuffle(images) <span class="comment">#shuffle</span></span><br><span class="line">            <span class="comment">#写入csv</span></span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(savepath,mode=<span class="string">&#x27;w&#x27;</span>,newline=<span class="string">&#x27;&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                writer = csv.writer(f)</span><br><span class="line">                <span class="keyword">for</span> img <span class="keyword">in</span> images:</span><br><span class="line">                    name = img.split(os.sep)[-<span class="number">2</span>]</span><br><span class="line">                    label = self.name2label[name]</span><br><span class="line">                    writer.writerow([img,label])</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;written into csv file:&#x27;</span>,savepath)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#从csv文件读取</span></span><br><span class="line">        images,labels = [],[]</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(savepath) <span class="keyword">as</span> f:</span><br><span class="line">            reader = csv.reader(f)</span><br><span class="line">            <span class="keyword">for</span> row <span class="keyword">in</span> reader:</span><br><span class="line">                img,label = row</span><br><span class="line">                label = <span class="built_in">int</span>(label)</span><br><span class="line">                images.append(img)</span><br><span class="line">                labels.append(label)</span><br><span class="line">        <span class="keyword">assert</span>  <span class="built_in">len</span>(images) == <span class="built_in">len</span>(labels)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span>  images,labels</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        :return: 数据集长度</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.images)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        :param item: range in [0,len(images)]</span></span><br><span class="line"><span class="string">        :return: self.images,self.labels</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        </span><br><span class="line">        img,label = self.images[item],self.labels[item]</span><br><span class="line">        </span><br><span class="line">        tf = transforms.Compose(</span><br><span class="line">            [<span class="keyword">lambda</span> x:Image.<span class="built_in">open</span>(x).convert(<span class="string">&#x27;RGB&#x27;</span>), <span class="comment"># open image and convert to RGB</span></span><br><span class="line">             transforms.Resize((<span class="built_in">int</span>(self.resize*<span class="number">1.25</span>),<span class="built_in">int</span>(self.resize*<span class="number">1.25</span>))),</span><br><span class="line">             transforms.RandomRotation(<span class="number">15</span>),</span><br><span class="line">             transforms.CenterCrop(self.resize),</span><br><span class="line">             transforms.ToTensor(),</span><br><span class="line">             transforms.Normalize(mean=[<span class="number">0.485</span>,<span class="number">0.456</span>,<span class="number">0.406</span>],std=[<span class="number">0.229</span>,<span class="number">0.224</span>,<span class="number">0.225</span>]),<span class="comment">#values computed from ImageNet，we could use it in other dataset   </span></span><br><span class="line">             </span><br><span class="line">             ]  </span><br><span class="line">        )</span><br><span class="line">        </span><br><span class="line">        img = tf(img)</span><br><span class="line">        label = torch.tensor(label)</span><br><span class="line">        <span class="keyword">return</span> img,label</span><br><span class="line">db = Pokemon(<span class="string">&#x27;./pokeman&#x27;</span>, <span class="number">224</span>, <span class="string">&#x27;train&#x27;</span>)</span><br><span class="line">x,y = <span class="built_in">next</span>(<span class="built_in">iter</span>(db))</span><br><span class="line"><span class="built_in">print</span>(x.shape,y.shape)</span><br></pre></td></tr></table></figure>
<pre><code>&#123;&#39;.ipynb_checkpoints&#39;: 0, &#39;bulbasaur&#39;: 1, &#39;charmander&#39;: 2, &#39;mewtwo&#39;: 3, &#39;pikachu&#39;: 4, &#39;squirtle&#39;: 5&#125;
written into csv file:  ./pokeman\image.csv
torch.Size([3, 224, 224]) torch.Size([])
</code></pre><h3 id="数据集加载：DataLoader"><a href="#数据集加载：DataLoader" class="headerlink" title="数据集加载：DataLoader"></a>数据集加载：DataLoader</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>  visdom</span><br><span class="line"><span class="keyword">import</span>  torchvision</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">db = Pokemon(<span class="string">&#x27;./pokeman&#x27;</span>, <span class="number">224</span>, <span class="string">&#x27;train&#x27;</span>)</span><br><span class="line">x,y = <span class="built_in">next</span>(<span class="built_in">iter</span>(db))</span><br><span class="line"><span class="built_in">print</span>(x.shape,y.shape)</span><br><span class="line">loader = DataLoader(db,batch_size=<span class="number">32</span>,shuffle=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<h2 id="网络创建"><a href="#网络创建" class="headerlink" title="网络创建"></a>网络创建</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Resnet.py</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span>  torch <span class="keyword">import</span>  nn</span><br><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ResBlk</span>(nn.Module):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    resnet block</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,ch_in,ch_out,stride=<span class="number">1</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :param ch_in:[b,ch,h,w]</span></span><br><span class="line"><span class="string">        :param ch_out:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">super</span>(ResBlk, self).__init__()</span><br><span class="line">        self.conv1 = nn.Conv2d(ch_in,ch_out,kernel_size=<span class="number">3</span>,stride=stride,padding=<span class="number">1</span>)</span><br><span class="line">        self.bn1 = nn.BatchNorm2d(ch_out)</span><br><span class="line">        self.conv2 = nn.Conv2d(ch_out,ch_out,kernel_size=<span class="number">3</span>,stride=<span class="number">1</span>,padding=<span class="number">1</span>)</span><br><span class="line">        self.bn2 = nn.BatchNorm2d(ch_out)</span><br><span class="line"></span><br><span class="line">        self.extra = nn.Sequential()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ch_out!=ch_in:</span><br><span class="line">            self.extra = nn.Sequential(</span><br><span class="line">                nn.Conv2d(ch_in,ch_out,kernel_size=<span class="number">1</span>,stride=stride),</span><br><span class="line">                nn.BatchNorm2d(ch_out)</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self,x</span>):</span><br><span class="line">        out =  F.relu(self.bn1(self.conv1(x)))</span><br><span class="line">        out = self.bn2(self.conv2(out))</span><br><span class="line"></span><br><span class="line">        <span class="comment">##short cut</span></span><br><span class="line">        <span class="comment">#extra module:[b,ch_in,h,w]=&gt;[b,ch_out,h,w]</span></span><br><span class="line">        <span class="comment">#element-wise add</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        out = self.extra(x) +out</span><br><span class="line">        <span class="keyword">return</span> out</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ResNet18</span>(nn.Module):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,num_class</span>):</span><br><span class="line">        <span class="built_in">super</span>(ResNet18, self).__init__()</span><br><span class="line">        self.conv1 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">3</span>,<span class="number">16</span>,kernel_size=<span class="number">3</span>,stride=<span class="number">3</span>,padding=<span class="number">0</span>),</span><br><span class="line">            nn.BatchNorm2d(<span class="number">16</span>)</span><br><span class="line">        )</span><br><span class="line">        <span class="comment">#followed 4 blocks</span></span><br><span class="line">        <span class="comment">#[b,16,h,w]=&gt;[b,32,h,w]</span></span><br><span class="line">        self.blk1 =ResBlk(<span class="number">16</span>,<span class="number">32</span>,stride=<span class="number">3</span>)</span><br><span class="line">        <span class="comment"># [b,32,h,w]=&gt;[b,64,h,w]</span></span><br><span class="line">        self.blk2 = ResBlk(<span class="number">32</span>,<span class="number">64</span>,stride=<span class="number">3</span>)</span><br><span class="line">        <span class="comment">#[b,64,h,w]=&gt;[b,128,h,w]</span></span><br><span class="line">        self.blk3 = ResBlk(<span class="number">64</span>,<span class="number">128</span>,stride=<span class="number">2</span>)</span><br><span class="line">        <span class="comment"># [b,128,h,w]=&gt;[b,256,h,w]</span></span><br><span class="line">        self.blk4 = ResBlk(<span class="number">128</span>,<span class="number">256</span>,stride=<span class="number">2</span>)</span><br><span class="line">        self.flatten = nn.Flatten()</span><br><span class="line">        self.outlayer = nn.Linear(<span class="number">256</span>*<span class="number">3</span>*<span class="number">3</span>,num_class)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self,x</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :param x:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        x = F.relu(self.conv1(x))</span><br><span class="line">        <span class="comment">#[b,64,h,w]=&gt;[b,1024,h,w]</span></span><br><span class="line">        x = self.blk1(x)</span><br><span class="line">        x = self.blk2(x)</span><br><span class="line">        x = self.blk3(x)</span><br><span class="line">        x = self.blk4(x)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;after conv:&quot;</span>,x.shape)</span><br><span class="line">        <span class="comment"># x = F.adaptive_max_pool2d(x,[1,1])</span></span><br><span class="line">        <span class="comment"># print(&quot;after pool,&quot;,x.shape)</span></span><br><span class="line">        x = self.flatten(x)</span><br><span class="line">        x = self.outlayer(x)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    blk = ResBlk(<span class="number">64</span>,<span class="number">128</span>)</span><br><span class="line">    tmp = torch.rand(<span class="number">2</span>,<span class="number">64</span>,<span class="number">224</span>,<span class="number">224</span>)</span><br><span class="line">    out = blk(tmp)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;block&#x27;</span>,out.shape)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    x  = torch.rand(<span class="number">2</span>,<span class="number">3</span>,<span class="number">224</span>,<span class="number">224</span>)</span><br><span class="line">    model = ResNet18(<span class="number">5</span>)</span><br><span class="line">    out = model(x)</span><br><span class="line">    <span class="built_in">print</span>(out.shape)</span><br><span class="line"></span><br><span class="line">    p = <span class="built_in">sum</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span>  p:p.numel(),model.parameters()))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;parameters size:&#x27;</span>,p)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Train-and-test"><a href="#Train-and-test" class="headerlink" title="Train and test"></a>Train and test</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(epoch):</span><br><span class="line">    train(train_db)</span><br><span class="line">    <span class="keyword">if</span> epoch%<span class="number">10</span>==<span class="number">0</span>:</span><br><span class="line">        val_acc = evaluate(val_db)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> val_loss <span class="keyword">is</span> the best:</span><br><span class="line">            save_ckpt()</span><br><span class="line">        <span class="keyword">if</span> out_of_patience():</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">load_ckpt()<span class="comment"># checkpoint model</span></span><br><span class="line">test_acc = evaluate(test_db)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#train_scratch.py</span></span><br><span class="line"><span class="keyword">import</span>  torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> optim,nn</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pokeman <span class="keyword">import</span> Pokemon</span><br><span class="line"><span class="keyword">from</span> Resnet <span class="keyword">import</span> ResNet18</span><br><span class="line"></span><br><span class="line">batchsz = <span class="number">32</span></span><br><span class="line">lr = <span class="number">1e-2</span></span><br><span class="line">epochs = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">device = torch.device(<span class="string">&#x27;cuda&#x27;</span>)</span><br><span class="line">torch.manual_seed(<span class="number">1234</span>)<span class="comment">##随机种子</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">train_db = Pokemon(<span class="string">&#x27;pokeman&#x27;</span>,<span class="number">224</span>,mode=<span class="string">&#x27;train&#x27;</span>)</span><br><span class="line">val_db = Pokemon(<span class="string">&#x27;pokeman&#x27;</span>,<span class="number">224</span>,mode=<span class="string">&#x27;val&#x27;</span>)</span><br><span class="line">test_db = Pokemon(<span class="string">&#x27;pokeman&#x27;</span>,<span class="number">224</span>,mode=<span class="string">&#x27;test&#x27;</span>)</span><br><span class="line">train_loader = DataLoader(train_db,batch_size=batchsz,shuffle=<span class="literal">True</span>,num_workers=<span class="number">4</span>)</span><br><span class="line">val_loader = DataLoader(val_db,batch_size=batchsz,shuffle=<span class="literal">True</span>,num_workers=<span class="number">2</span>)</span><br><span class="line">test_loader = DataLoader(test_db,batch_size=batchsz,shuffle=<span class="literal">True</span>,num_workers=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">evaluate</span>(<span class="params">model,loader</span>):</span><br><span class="line">    correct = <span class="number">0</span></span><br><span class="line">    total = <span class="built_in">len</span>(loader.dataset)</span><br><span class="line">    <span class="keyword">for</span> x,y <span class="keyword">in</span> loader:</span><br><span class="line">        x,y = x.to(device),y.to(device)</span><br><span class="line">        <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">            logits = model(x)</span><br><span class="line">            pred = logits.argmax(dim=<span class="number">1</span>)</span><br><span class="line">        correct += torch.eq(pred,y).<span class="built_in">sum</span>().<span class="built_in">float</span>().item()</span><br><span class="line">    <span class="keyword">return</span> correct/total</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    model = ResNet18(<span class="number">5</span>).to(device)</span><br><span class="line">    optimizer = optim.Adam(model.parameters(),lr=lr)</span><br><span class="line">    criteon = nn.CrossEntropyLoss()</span><br><span class="line"></span><br><span class="line">    best_acc,best_epoch=<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">    global_step=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(epochs):</span><br><span class="line">        <span class="keyword">for</span> step,(img,label) <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_loader):</span><br><span class="line"></span><br><span class="line">            <span class="comment"># x:[b,3,224,224], y:[5]</span></span><br><span class="line">            img,label = img.to(device),label.to(device)</span><br><span class="line"></span><br><span class="line">            logits = model(img)</span><br><span class="line">            loss = criteon(logits,label)</span><br><span class="line"></span><br><span class="line">            optimizer.zero_grad()</span><br><span class="line">            loss.backward()</span><br><span class="line">            optimizer.step()</span><br><span class="line">          </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> epoch%<span class="number">1</span> ==<span class="number">0</span>:</span><br><span class="line">            val_acc = evaluate(model,val_loader)</span><br><span class="line">            <span class="keyword">if</span> val_acc&gt;best_acc:</span><br><span class="line">                best_epoch = epoch</span><br><span class="line">                best_acc = val_acc</span><br><span class="line"></span><br><span class="line">                torch.save(model.state_dict(),<span class="string">&#x27;best.mdl&#x27;</span>)</span><br><span class="line">            viz.line([val_acc], [epoch], win=<span class="string">&#x27;val_acc&#x27;</span>, update=<span class="string">&#x27;append&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;best acc:&#x27;</span>,best_acc,<span class="string">&#x27;best epoch&#x27;</span>,best_epoch)</span><br><span class="line"></span><br><span class="line">    model.load_state_dict(torch.load(<span class="string">&#x27;best.mdl&#x27;</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;loaded from checkpoint!&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    test_acc = evaluate(model,test_loader)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;test acc&#x27;</span>,test_acc)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>best acc: 0.8583690987124464 best epoch 5</p>
<p>test acc 0.8497854077253219</p>
<h1 id="optional-迁移学习"><a href="#optional-迁移学习" class="headerlink" title="optional: 迁移学习"></a>optional: 迁移学习</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>  torch</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> optim,nn</span><br><span class="line"><span class="keyword">import</span>  visdom</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pokeman <span class="keyword">import</span> Pokemon</span><br><span class="line"><span class="keyword">from</span> torchvision.models <span class="keyword">import</span> resnet18 <span class="comment">##从网络获取模型</span></span><br><span class="line"></span><br><span class="line">batchsz = <span class="number">32</span></span><br><span class="line">lr = <span class="number">1e-2</span></span><br><span class="line">epochs = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">device = torch.device(<span class="string">&#x27;cuda&#x27;</span>)</span><br><span class="line">torch.manual_seed(<span class="number">1234</span>)<span class="comment">##随机种子</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">train_db = Pokemon(<span class="string">&#x27;pokeman&#x27;</span>,<span class="number">224</span>,mode=<span class="string">&#x27;train&#x27;</span>)</span><br><span class="line">val_db = Pokemon(<span class="string">&#x27;pokeman&#x27;</span>,<span class="number">224</span>,mode=<span class="string">&#x27;val&#x27;</span>)</span><br><span class="line">test_db = Pokemon(<span class="string">&#x27;pokeman&#x27;</span>,<span class="number">224</span>,mode=<span class="string">&#x27;test&#x27;</span>)</span><br><span class="line">train_loader = DataLoader(train_db,batch_size=batchsz,shuffle=<span class="literal">True</span>,num_workers=<span class="number">4</span>)</span><br><span class="line">val_loader = DataLoader(val_db,batch_size=batchsz,shuffle=<span class="literal">True</span>,num_workers=<span class="number">2</span>)</span><br><span class="line">test_loader = DataLoader(test_db,batch_size=batchsz,shuffle=<span class="literal">True</span>,num_workers=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">viz = visdom.Visdom()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">evaluate</span>(<span class="params">model,loader</span>):</span><br><span class="line">    correct = <span class="number">0</span></span><br><span class="line">    total = <span class="built_in">len</span>(loader.dataset)</span><br><span class="line">    <span class="keyword">for</span> x,y <span class="keyword">in</span> loader:</span><br><span class="line">        x,y = x.to(device),y.to(device)</span><br><span class="line">        <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">            logits = model(x)</span><br><span class="line">            pred = logits.argmax(dim=<span class="number">1</span>)</span><br><span class="line">        correct = torch.eq(pred,y).<span class="built_in">sum</span>().<span class="built_in">float</span>().item()</span><br><span class="line">    <span class="keyword">return</span> correct/total</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># model = ResNet18(5).to(device)</span></span><br><span class="line">    <span class="comment">#-----------------------------------------------------------------------------------</span></span><br><span class="line">    trained_model = resnet18(pretrained=<span class="literal">True</span>)</span><br><span class="line">                <span class="comment">#*用于迭代取出list中的内容</span></span><br><span class="line">    model = nn.Sequential(*<span class="built_in">list</span>(trained_model.children())[:-<span class="number">1</span>],<span class="comment">#[b,512,1,1]</span></span><br><span class="line">                          nn.Flatten(),<span class="comment">#[b,512,1,1]=&gt;[b,512]</span></span><br><span class="line">                          nn.Linear(<span class="number">512</span>,<span class="number">5</span>)</span><br><span class="line">                          ).to(device)</span><br><span class="line">    <span class="comment"># x = torch.rand(2,3,224,224)</span></span><br><span class="line">    <span class="comment"># print(model(x).shape)</span></span><br><span class="line">    <span class="comment">#---------------------------------------------------------------------------------------</span></span><br><span class="line">    optimizer = optim.Adam(model.parameters(),lr=lr)</span><br><span class="line">    criteon = nn.CrossEntropyLoss()</span><br><span class="line"></span><br><span class="line">    best_acc,best_epoch=<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">    viz.line([<span class="number">0</span>],[-<span class="number">1</span>],win=<span class="string">&#x27;loss&#x27;</span>,opts=<span class="built_in">dict</span>(title=<span class="string">&#x27;loss&#x27;</span>))</span><br><span class="line">    viz.line([<span class="number">0</span>],[-<span class="number">1</span>],win=<span class="string">&#x27;val_acc&#x27;</span>,opts=<span class="built_in">dict</span>(title=<span class="string">&#x27;val_acc&#x27;</span>))</span><br><span class="line">    global_step=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(epochs):</span><br><span class="line">        <span class="keyword">for</span> step,(img,label) <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_loader):</span><br><span class="line"></span><br><span class="line">            <span class="comment"># x:[b,3,224,224], y:[5]</span></span><br><span class="line">            img,label = img.to(device),label.to(device)</span><br><span class="line"></span><br><span class="line">            logits = model(img)</span><br><span class="line">            loss = criteon(logits,label)</span><br><span class="line"></span><br><span class="line">            optimizer.zero_grad()</span><br><span class="line">            loss.backward()</span><br><span class="line">            optimizer.step()</span><br><span class="line">            viz.line([loss.item()], [global_step], win=<span class="string">&#x27;loss&#x27;</span>, update=<span class="string">&#x27;append&#x27;</span>)</span><br><span class="line">            global_step+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> epoch%<span class="number">1</span> ==<span class="number">0</span>:</span><br><span class="line">            val_acc = evaluate(model,val_loader)</span><br><span class="line">            <span class="keyword">if</span> val_acc&gt;best_acc:</span><br><span class="line">                best_epoch = epoch</span><br><span class="line">                best_acc = val_acc</span><br><span class="line"></span><br><span class="line">                torch.save(model.state_dict(),<span class="string">&#x27;best.mdl&#x27;</span>)</span><br><span class="line">            viz.line([val_acc], [epochs], win=<span class="string">&#x27;val_acc&#x27;</span>, update=<span class="string">&#x27;append&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;best acc:&#x27;</span>,best_acc,<span class="string">&#x27;best epoch&#x27;</span>,best_epoch)</span><br><span class="line"></span><br><span class="line">    model.load_state_dict(torch.load(<span class="string">&#x27;best.mdl&#x27;</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;loaded from checkpoint!&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    test_acc = evaluate(model,test_loader)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;test acc&#x27;</span>,test_acc)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>best acc: 0.8412017167381974 best epoch 8</p>
<p>test acc 0.8025751072961373</p>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>邻接矩阵表示成PyG需要的edge_index并进行带边权的网络构建</title>
    <url>/posts/35a1541/</url>
    <content><![CDATA[<h1 id="邻接矩阵-to-pyg需要的edge-index格式"><a href="#邻接矩阵-to-pyg需要的edge-index格式" class="headerlink" title="邻接矩阵 to pyg需要的edge_index格式"></a>邻接矩阵 to pyg需要的edge_index格式</h1><span id="more"></span>
<h2 id="scipy"><a href="#scipy" class="headerlink" title="scipy"></a>scipy</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line">A = torch.rand([<span class="number">10</span>,<span class="number">10</span>]) <span class="comment"># 10*10的邻接矩阵A，带有权值，而非0/1</span></span><br><span class="line">A</span><br></pre></td></tr></table></figure>
<pre><code>tensor([[0.8253, 0.2458, 0.9340, 0.4631, 0.5114, 0.3248, 0.8528, 0.6354, 0.2988,
         0.1087],
        [0.0190, 0.5693, 0.4843, 0.9588, 0.6011, 0.5755, 0.4621, 0.7694, 0.0637,
         0.9790],
        [0.6978, 0.9686, 0.9701, 0.2234, 0.5633, 0.9978, 0.9766, 0.3365, 0.3512,
         0.2396],
        [0.3582, 0.9965, 0.7739, 0.5641, 0.7275, 0.3078, 0.1826, 0.5449, 0.6566,
         0.1949],
        [0.8194, 0.7996, 0.9177, 0.3419, 0.5239, 0.7048, 0.4503, 0.0758, 0.2244,
         0.0659],
        [0.6131, 0.3546, 0.0789, 0.2735, 0.0781, 0.8000, 0.0587, 0.6644, 0.2678,
         0.6351],
        [0.7244, 0.0463, 0.9280, 0.6456, 0.6837, 0.0763, 0.0759, 0.0440, 0.1849,
         0.8942],
        [0.3589, 0.6925, 0.2334, 0.3476, 0.6695, 0.1048, 0.1470, 0.5548, 0.4736,
         0.6934],
        [0.0356, 0.8016, 0.6176, 0.2867, 0.1340, 0.7196, 0.0562, 0.5548, 0.7376,
         0.2841],
        [0.9301, 0.1725, 0.4012, 0.3893, 0.8366, 0.1587, 0.3342, 0.7945, 0.8123,
         0.8724]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> scipy.sparse <span class="keyword">as</span> sp</span><br><span class="line">adj  = sp.coo_matrix(A) <span class="comment">#转换成coo_matrix矩阵</span></span><br><span class="line">values = adj.data</span><br><span class="line">values,adj.row,adj.col</span><br></pre></td></tr></table></figure>
<pre><code>(array([0.825252  , 0.24581629, 0.9340454 , 0.4631123 , 0.51142365,
        0.32479858, 0.85282457, 0.63537604, 0.29877287, 0.10873711,
        0.01895636, 0.5693259 , 0.48427123, 0.9587981 , 0.6010562 ,
        0.57548887, 0.46208388, 0.7693816 , 0.06371653, 0.97895676,
        0.6978117 , 0.9685761 , 0.97011906, 0.22341514, 0.56326205,
        0.9978037 , 0.97661865, 0.33654213, 0.35123014, 0.23959029,
        0.358207  , 0.99651885, 0.7739324 , 0.5641022 , 0.72754997,
        0.3077591 , 0.18257308, 0.5449101 , 0.65663534, 0.1949212 ,
        0.8193548 , 0.79964596, 0.9176568 , 0.34189552, 0.5239384 ,
        0.70477635, 0.4503097 , 0.07584941, 0.22442049, 0.06589556,
        0.6130815 , 0.35458   , 0.07890564, 0.27350843, 0.07805085,
        0.79995   , 0.05868119, 0.66441715, 0.267847  , 0.6351336 ,
        0.72437716, 0.04632962, 0.92803836, 0.645646  , 0.6836786 ,
        0.07632524, 0.07594979, 0.04397732, 0.18492383, 0.89419115,
        0.3588807 , 0.6925135 , 0.23337674, 0.34763372, 0.66951907,
        0.10478634, 0.14702266, 0.55476344, 0.47362745, 0.69343317,
        0.03562325, 0.80160064, 0.6175768 , 0.2867241 , 0.13401723,
        0.719559  , 0.05618161, 0.55481714, 0.7375902 , 0.28414857,
        0.9300911 , 0.17248052, 0.4012187 , 0.38931435, 0.83664143,
        0.15867668, 0.3341686 , 0.7945494 , 0.81226593, 0.8724434 ],
       dtype=float32),
 array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4,
        4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6,
        6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8,
        8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9], dtype=int32),
 array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1,
        2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3,
        4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5,
        6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7,
        8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9], dtype=int32))
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">indices = np.vstack((adj.row,adj.col)) <span class="comment"># 我们需要的coo形式的edge_index</span></span><br><span class="line">edge_index = torch.LongTensor(indices)<span class="comment">#PyG需要的edge_index</span></span><br><span class="line">edge_index,edge_index.shape</span><br></pre></td></tr></table></figure>
<pre><code>(tensor([[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2,
          2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4,
          4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7,
          7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9,
          9, 9, 9, 9],
         [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3,
          4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7,
          8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1,
          2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5,
          6, 7, 8, 9]]),
 torch.Size([2, 100]))
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">edge_attr = adj.data <span class="comment">#边权值</span></span><br><span class="line">edge_attr = torch.FloatTensor(edge_attr)<span class="comment">#to float tensor</span></span><br><span class="line">edge_attr,edge_attr.shape</span><br></pre></td></tr></table></figure>
<pre><code>(tensor([0.8253, 0.2458, 0.9340, 0.4631, 0.5114, 0.3248, 0.8528, 0.6354, 0.2988,
         0.1087, 0.0190, 0.5693, 0.4843, 0.9588, 0.6011, 0.5755, 0.4621, 0.7694,
         0.0637, 0.9790, 0.6978, 0.9686, 0.9701, 0.2234, 0.5633, 0.9978, 0.9766,
         0.3365, 0.3512, 0.2396, 0.3582, 0.9965, 0.7739, 0.5641, 0.7275, 0.3078,
         0.1826, 0.5449, 0.6566, 0.1949, 0.8194, 0.7996, 0.9177, 0.3419, 0.5239,
         0.7048, 0.4503, 0.0758, 0.2244, 0.0659, 0.6131, 0.3546, 0.0789, 0.2735,
         0.0781, 0.8000, 0.0587, 0.6644, 0.2678, 0.6351, 0.7244, 0.0463, 0.9280,
         0.6456, 0.6837, 0.0763, 0.0759, 0.0440, 0.1849, 0.8942, 0.3589, 0.6925,
         0.2334, 0.3476, 0.6695, 0.1048, 0.1470, 0.5548, 0.4736, 0.6934, 0.0356,
         0.8016, 0.6176, 0.2867, 0.1340, 0.7196, 0.0562, 0.5548, 0.7376, 0.2841,
         0.9301, 0.1725, 0.4012, 0.3893, 0.8366, 0.1587, 0.3342, 0.7945, 0.8123,
         0.8724]),
 torch.Size([100]))
</code></pre><h2 id="torch"><a href="#torch" class="headerlink" title="torch**"></a>torch<em>**</em></h2><p>使用前面的方法，当传入cuda的输入然后进行转换时，前面的方法只能在cpu上执行，因为cuda不支持numpy(),需要进行cpu和cuda的转换。（一直以为是因为数据传输等方面可能的影响导致我的速度变慢，但是似乎影响更大的是因为后续模型加载非成batch)）</p>
<p>torch的方法不需要</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line">A = torch.rand([<span class="number">10</span>,<span class="number">10</span>]) <span class="comment"># 10*10的邻接矩阵A，带有权值，而非0/1</span></span><br><span class="line">A</span><br></pre></td></tr></table></figure>
<pre><code>tensor([[0.8176, 0.2545, 0.6473, 0.2937, 0.9869, 0.0929, 0.6526, 0.6831, 0.0242,
         0.3227],
        [0.8430, 0.0125, 0.0166, 0.2306, 0.6767, 0.7800, 0.3947, 0.5706, 0.1307,
         0.3265],
        [0.8983, 0.5701, 0.0590, 0.0370, 0.1142, 0.9176, 0.0413, 0.7737, 0.8839,
         0.9673],
        [0.2120, 0.0877, 0.8496, 0.2748, 0.2316, 0.1640, 0.2160, 0.1306, 0.4602,
         0.9815],
        [0.8076, 0.4725, 0.8042, 0.3854, 0.4384, 0.9577, 0.5992, 0.5335, 0.9595,
         0.1808],
        [0.3166, 0.5219, 0.1348, 0.2726, 0.6527, 0.7875, 0.2952, 0.6067, 0.5722,
         0.0738],
        [0.2799, 0.3344, 0.2588, 0.3888, 0.6586, 0.3389, 0.3849, 0.0184, 0.8913,
         0.5702],
        [0.5489, 0.5952, 0.3463, 0.6634, 0.1480, 0.4949, 0.3449, 0.6737, 0.5059,
         0.1255],
        [0.3011, 0.6796, 0.9407, 0.1118, 0.2194, 0.9374, 0.2392, 0.1681, 0.4226,
         0.9818],
        [0.7948, 0.4114, 0.2621, 0.5588, 0.2609, 0.7126, 0.6315, 0.7893, 0.2553,
         0.4072]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">adj = A.to_sparse()</span><br><span class="line">adj, adj.indices(),adj.values()</span><br></pre></td></tr></table></figure>
<pre><code>(tensor(indices=tensor([[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                         1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3,
                         3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5,
                         5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7,
                         7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9,
                         9, 9, 9, 9, 9],
                        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8,
                         9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7,
                         8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6,
                         7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5,
                         6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4,
                         5, 6, 7, 8, 9]]),
        values=tensor([0.8176, 0.2545, 0.6473, 0.2937, 0.9869, 0.0929, 0.6526,
                       0.6831, 0.0242, 0.3227, 0.8430, 0.0125, 0.0166, 0.2306,
                       0.6767, 0.7800, 0.3947, 0.5706, 0.1307, 0.3265, 0.8983,
                       0.5701, 0.0590, 0.0370, 0.1142, 0.9176, 0.0413, 0.7737,
                       0.8839, 0.9673, 0.2120, 0.0877, 0.8496, 0.2748, 0.2316,
                       0.1640, 0.2160, 0.1306, 0.4602, 0.9815, 0.8076, 0.4725,
                       0.8042, 0.3854, 0.4384, 0.9577, 0.5992, 0.5335, 0.9595,
                       0.1808, 0.3166, 0.5219, 0.1348, 0.2726, 0.6527, 0.7875,
                       0.2952, 0.6067, 0.5722, 0.0738, 0.2799, 0.3344, 0.2588,
                       0.3888, 0.6586, 0.3389, 0.3849, 0.0184, 0.8913, 0.5702,
                       0.5489, 0.5952, 0.3463, 0.6634, 0.1480, 0.4949, 0.3449,
                       0.6737, 0.5059, 0.1255, 0.3011, 0.6796, 0.9407, 0.1118,
                       0.2194, 0.9374, 0.2392, 0.1681, 0.4226, 0.9818, 0.7948,
                       0.4114, 0.2621, 0.5588, 0.2609, 0.7126, 0.6315, 0.7893,
                       0.2553, 0.4072]),
        size=(10, 10), nnz=100, layout=torch.sparse_coo),
 tensor([[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2,
          2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4,
          4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7,
          7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9,
          9, 9, 9, 9],
         [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3,
          4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7,
          8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1,
          2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5,
          6, 7, 8, 9]]),
 tensor([0.8176, 0.2545, 0.6473, 0.2937, 0.9869, 0.0929, 0.6526, 0.6831, 0.0242,
         0.3227, 0.8430, 0.0125, 0.0166, 0.2306, 0.6767, 0.7800, 0.3947, 0.5706,
         0.1307, 0.3265, 0.8983, 0.5701, 0.0590, 0.0370, 0.1142, 0.9176, 0.0413,
         0.7737, 0.8839, 0.9673, 0.2120, 0.0877, 0.8496, 0.2748, 0.2316, 0.1640,
         0.2160, 0.1306, 0.4602, 0.9815, 0.8076, 0.4725, 0.8042, 0.3854, 0.4384,
         0.9577, 0.5992, 0.5335, 0.9595, 0.1808, 0.3166, 0.5219, 0.1348, 0.2726,
         0.6527, 0.7875, 0.2952, 0.6067, 0.5722, 0.0738, 0.2799, 0.3344, 0.2588,
         0.3888, 0.6586, 0.3389, 0.3849, 0.0184, 0.8913, 0.5702, 0.5489, 0.5952,
         0.3463, 0.6634, 0.1480, 0.4949, 0.3449, 0.6737, 0.5059, 0.1255, 0.3011,
         0.6796, 0.9407, 0.1118, 0.2194, 0.9374, 0.2392, 0.1681, 0.4226, 0.9818,
         0.7948, 0.4114, 0.2621, 0.5588, 0.2609, 0.7126, 0.6315, 0.7893, 0.2553,
         0.4072]))
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">indices = adj.indices() <span class="comment"># 我们需要的coo形式的edge_index</span></span><br><span class="line">edge_index = indices<span class="comment">#PyG需要的edge_index</span></span><br><span class="line">edge_index,edge_index.shape</span><br></pre></td></tr></table></figure>
<pre><code>(tensor([[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2,
          2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4,
          4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7,
          7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9,
          9, 9, 9, 9],
         [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3,
          4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7,
          8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1,
          2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5,
          6, 7, 8, 9]]),
 torch.Size([2, 100]))
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">edge_attr = adj.values()</span><br><span class="line">edge_attr,edge_attr.shape</span><br></pre></td></tr></table></figure>
<pre><code>(tensor([0.8176, 0.2545, 0.6473, 0.2937, 0.9869, 0.0929, 0.6526, 0.6831, 0.0242,
         0.3227, 0.8430, 0.0125, 0.0166, 0.2306, 0.6767, 0.7800, 0.3947, 0.5706,
         0.1307, 0.3265, 0.8983, 0.5701, 0.0590, 0.0370, 0.1142, 0.9176, 0.0413,
         0.7737, 0.8839, 0.9673, 0.2120, 0.0877, 0.8496, 0.2748, 0.2316, 0.1640,
         0.2160, 0.1306, 0.4602, 0.9815, 0.8076, 0.4725, 0.8042, 0.3854, 0.4384,
         0.9577, 0.5992, 0.5335, 0.9595, 0.1808, 0.3166, 0.5219, 0.1348, 0.2726,
         0.6527, 0.7875, 0.2952, 0.6067, 0.5722, 0.0738, 0.2799, 0.3344, 0.2588,
         0.3888, 0.6586, 0.3389, 0.3849, 0.0184, 0.8913, 0.5702, 0.5489, 0.5952,
         0.3463, 0.6634, 0.1480, 0.4949, 0.3449, 0.6737, 0.5059, 0.1255, 0.3011,
         0.6796, 0.9407, 0.1118, 0.2194, 0.9374, 0.2392, 0.1681, 0.4226, 0.9818,
         0.7948, 0.4114, 0.2621, 0.5588, 0.2609, 0.7126, 0.6315, 0.7893, 0.2553,
         0.4072]),
 torch.Size([100]))
</code></pre><h1 id="edge-index-to-邻接矩阵"><a href="#edge-index-to-邻接矩阵" class="headerlink" title="edge_index to 邻接矩阵"></a>edge_index to 邻接矩阵</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> scipy.sparse <span class="keyword">as</span> sp</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> sparse_coo_tensor</span><br><span class="line">adj = sparse_coo_tensor(edge_index,edge_attr,[<span class="number">10</span>,<span class="number">10</span>])</span><br><span class="line">adj.to_dense()</span><br></pre></td></tr></table></figure>
<pre><code>tensor([[4.5977e-01, 6.6455e-01, 4.3946e-01, 3.8642e-01, 1.2331e-01, 2.9945e-01,
         2.5433e-01, 9.7476e-01, 4.5961e-04, 5.9594e-02],
        [2.2455e-01, 9.7698e-01, 8.7531e-01, 2.8142e-01, 7.0980e-01, 6.2595e-01,
         2.3625e-01, 5.7737e-01, 4.4227e-01, 6.5420e-01],
        [5.4512e-01, 2.4614e-01, 6.9270e-01, 6.8005e-01, 1.3384e-01, 5.9974e-01,
         9.2275e-01, 3.6578e-01, 3.5667e-01, 5.8081e-01],
        [9.6142e-02, 8.5471e-01, 5.9899e-02, 3.0163e-01, 2.9641e-01, 2.8706e-01,
         4.8757e-01, 8.8466e-01, 3.4357e-01, 9.9034e-01],
        [4.5909e-01, 7.2475e-01, 2.4294e-01, 7.3560e-01, 3.2247e-01, 7.6749e-01,
         3.6008e-01, 3.0816e-01, 7.4665e-01, 6.7713e-01],
        [6.6836e-01, 8.9111e-01, 8.0428e-01, 7.9984e-01, 6.5296e-01, 8.1743e-01,
         8.8702e-01, 3.6678e-01, 4.2774e-01, 2.3170e-02],
        [8.1350e-01, 1.6834e-01, 7.7933e-02, 3.8021e-01, 9.7750e-01, 5.6143e-01,
         7.9341e-01, 3.7514e-01, 9.3114e-01, 5.6821e-01],
        [8.4002e-01, 9.2273e-01, 5.6649e-01, 7.5386e-01, 9.1587e-01, 3.9596e-02,
         8.9435e-01, 5.6476e-01, 2.3289e-01, 1.9653e-01],
        [2.1682e-01, 2.8950e-01, 7.5310e-01, 6.7648e-01, 5.1057e-02, 1.6519e-01,
         5.8807e-01, 9.4542e-02, 6.3111e-01, 2.9049e-01],
        [5.7742e-02, 3.1503e-01, 5.6936e-01, 2.2748e-01, 4.8668e-01, 6.4949e-01,
         6.1752e-01, 3.9269e-01, 2.7897e-01, 5.5806e-01]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">adj = sp.coo_matrix((edge_attr,(edge_index[<span class="number">0</span>],edge_index[<span class="number">1</span>])),shape=[<span class="number">10</span>,<span class="number">10</span>])</span><br><span class="line">adj.toarray()</span><br></pre></td></tr></table></figure>
<pre><code>array([[4.5977378e-01, 6.6455245e-01, 4.3945801e-01, 3.8642406e-01,
        1.2331247e-01, 2.9944807e-01, 2.5433010e-01, 9.7475851e-01,
        4.5961142e-04, 5.9593856e-02],
       [2.2454953e-01, 9.7697508e-01, 8.7531334e-01, 2.8141612e-01,
        7.0980257e-01, 6.2595367e-01, 2.3624879e-01, 5.7737088e-01,
        4.4226754e-01, 6.5420014e-01],
       [5.4512197e-01, 2.4613553e-01, 6.9269532e-01, 6.8004644e-01,
        1.3383734e-01, 5.9973723e-01, 9.2274553e-01, 3.6578351e-01,
        3.5666680e-01, 5.8080733e-01],
       [9.6142113e-02, 8.5471165e-01, 5.9899449e-02, 3.0162632e-01,
        2.9641372e-01, 2.8705674e-01, 4.8757398e-01, 8.8466209e-01,
        3.4356719e-01, 9.9034435e-01],
       [4.5909441e-01, 7.2474545e-01, 2.4293584e-01, 7.3560286e-01,
        3.2246715e-01, 7.6749289e-01, 3.6007798e-01, 3.0815858e-01,
        7.4665487e-01, 6.7713338e-01],
       [6.6836429e-01, 8.9111018e-01, 8.0427557e-01, 7.9984426e-01,
        6.5295666e-01, 8.1743485e-01, 8.8702154e-01, 3.6678237e-01,
        4.2774427e-01, 2.3170471e-02],
       [8.1350172e-01, 1.6834372e-01, 7.7932715e-02, 3.8021082e-01,
        9.7749555e-01, 5.6143039e-01, 7.9341477e-01, 3.7514049e-01,
        9.3114382e-01, 5.6820768e-01],
       [8.4002483e-01, 9.2273450e-01, 5.6649190e-01, 7.5385606e-01,
        9.1587120e-01, 3.9596200e-02, 8.9435184e-01, 5.6475997e-01,
        2.3288828e-01, 1.9652534e-01],
       [2.1682233e-01, 2.8950059e-01, 7.5310403e-01, 6.7648250e-01,
        5.1056564e-02, 1.6518539e-01, 5.8806950e-01, 9.4541669e-02,
        6.3110876e-01, 2.9048622e-01],
       [5.7742238e-02, 3.1502587e-01, 5.6935811e-01, 2.2748303e-01,
        4.8667991e-01, 6.4949030e-01, 6.1752105e-01, 3.9268762e-01,
        2.7897447e-01, 5.5806071e-01]], dtype=float32)
</code></pre><h1 id="构建自定义边权重的GNN"><a href="#构建自定义边权重的GNN" class="headerlink" title="构建自定义边权重的GNN"></a>构建自定义边权重的GNN</h1><p>胡乱定值的<br>代码修改自：<a href="https://zhuanlan.zhihu.com/p/426907570">https://zhuanlan.zhihu.com/p/426907570</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torch_geometric.nn <span class="keyword">import</span> GATConv</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Net</span>(torch.nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(Net, self).__init__()</span><br><span class="line">        self.conv1 = GCNConv(data.num_features, <span class="number">16</span>, cached=<span class="literal">True</span>,</span><br><span class="line">                             normalize=<span class="literal">True</span>)</span><br><span class="line"><span class="comment">#         self.conv1 = GATConv(data.num_features, 16)</span></span><br><span class="line">        <span class="comment">#self.conv2 = GCNConv(16, data.num_classes, cached=True,</span></span><br><span class="line">        self.conv2 = GCNConv(<span class="number">16</span>, <span class="number">2</span>, cached=<span class="literal">True</span>,</span><br><span class="line">                            normalize=<span class="literal">True</span>)</span><br><span class="line"><span class="comment">#         self.conv2 = GATConv(16, 2)</span></span><br><span class="line">        <span class="comment"># self.conv1 = ChebConv(data.num_features, 16, K=2)</span></span><br><span class="line">        <span class="comment"># self.conv2 = ChebConv(16, data.num_features, K=2)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self</span>):</span><br><span class="line">        x, edge_index, edge_weight = data.x, data.edge_index, data.edge_attr</span><br><span class="line">        x = F.relu(self.conv1(x, edge_index, edge_weight))</span><br><span class="line">        x = F.dropout(x, training=self.training)</span><br><span class="line">        x = self.conv2(x, edge_index, edge_weight)</span><br><span class="line">        <span class="keyword">return</span> F.log_softmax(x, dim=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">from</span> torch_geometric.nn <span class="keyword">import</span> GCNConv, ChebConv  <span class="comment"># noqa</span></span><br><span class="line"><span class="keyword">from</span> torch_geometric.data <span class="keyword">import</span> data <span class="keyword">as</span> D</span><br><span class="line"><span class="keyword">from</span> torch_geometric.data <span class="keyword">import</span> dataset</span><br><span class="line"></span><br><span class="line">x = torch.tensor([[<span class="number">1</span>],[<span class="number">2</span>],[<span class="number">3</span>],[<span class="number">4</span>],[<span class="number">5</span>],[<span class="number">6</span>],[<span class="number">7</span>],[<span class="number">8</span>],[<span class="number">9</span>],[<span class="number">10</span>]], dtype=torch.<span class="built_in">float</span>)   <span class="comment"># N x emb(in)</span></span><br><span class="line"><span class="built_in">print</span>(x.shape)</span><br><span class="line">x = torch.ones(<span class="number">10</span>,dtype=torch.<span class="built_in">float</span>).unsqueeze(-<span class="number">1</span>)</span><br><span class="line"><span class="comment">#print(x.shape)</span></span><br><span class="line">y = torch.randint(<span class="number">0</span>,<span class="number">2</span>,[<span class="number">10</span>])</span><br><span class="line">train_mask = torch.tensor([<span class="literal">True</span>, <span class="literal">True</span>, <span class="literal">True</span>,<span class="literal">True</span>,<span class="literal">True</span>,<span class="literal">True</span>,<span class="literal">True</span>,<span class="literal">True</span>,<span class="literal">True</span>,<span class="literal">True</span>], dtype=torch.<span class="built_in">bool</span>)</span><br><span class="line">val_mask=train_mask</span><br><span class="line">test_mask=train_mask</span><br><span class="line">data=D.Data()</span><br><span class="line">data.x,data.y,data.edge_index,data.edge_attr,data.train_mask,data.val_mask,data.test_mask \</span><br><span class="line">    = x,y,edge_index,edge_attr,train_mask,val_mask,test_mask</span><br></pre></td></tr></table></figure>
<pre><code>torch.Size([10, 1])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">device = torch.device(<span class="string">&#x27;cuda&#x27;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&#x27;cpu&#x27;</span>)</span><br><span class="line">model, data = Net().to(device), data.to(device)</span><br><span class="line">optimizer = torch.optim.Adam([</span><br><span class="line">    <span class="built_in">dict</span>(params=model.conv1.parameters(), weight_decay=<span class="number">5e-4</span>),</span><br><span class="line">    <span class="built_in">dict</span>(params=model.conv2.parameters(), weight_decay=<span class="number">0</span>)</span><br><span class="line">], lr=<span class="number">0.01</span>)  <span class="comment"># Only perform weight-decay on first convolution.</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">train</span>():</span><br><span class="line">    model.train()</span><br><span class="line">    optimizer.zero_grad()</span><br><span class="line">    F.nll_loss(model()[data.train_mask], data.y[data.train_mask]).backward()</span><br><span class="line">    <span class="comment">#F.nll_loss(model()[data], data.y).backward() #不行！</span></span><br><span class="line">    optimizer.step()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@torch.no_grad()</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    model.<span class="built_in">eval</span>()</span><br><span class="line">    logits, accs = model(), []</span><br><span class="line">    <span class="keyword">for</span> _, mask <span class="keyword">in</span> data(<span class="string">&#x27;train_mask&#x27;</span>, <span class="string">&#x27;val_mask&#x27;</span>, <span class="string">&#x27;test_mask&#x27;</span>):</span><br><span class="line">        pred = logits[mask].<span class="built_in">max</span>(<span class="number">1</span>)[<span class="number">1</span>]</span><br><span class="line">        acc = pred.eq(data.y[mask]).<span class="built_in">sum</span>().item() / mask.<span class="built_in">sum</span>().item()</span><br><span class="line">        accs.append(acc)</span><br><span class="line">    <span class="keyword">return</span> accs</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">best_val_acc = test_acc = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">    train()</span><br><span class="line">    train_acc, val_acc, tmp_test_acc = test()</span><br><span class="line">    <span class="keyword">if</span> val_acc &gt; best_val_acc:</span><br><span class="line">        best_val_acc = val_acc</span><br><span class="line">        test_acc = tmp_test_acc</span><br><span class="line">    log = <span class="string">&#x27;Epoch: &#123;:03d&#125;, Train: &#123;:.4f&#125;, Val: &#123;:.4f&#125;, Test: &#123;:.4f&#125;&#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(log.<span class="built_in">format</span>(epoch, train_acc, best_val_acc, test_acc))</span><br></pre></td></tr></table></figure>
<pre><code>Epoch: 001, Train: 0.5000, Val: 0.5000, Test: 0.5000
Epoch: 002, Train: 0.5000, Val: 0.5000, Test: 0.5000
Epoch: 003, Train: 0.5000, Val: 0.5000, Test: 0.5000
Epoch: 004, Train: 0.5000, Val: 0.5000, Test: 0.5000
Epoch: 005, Train: 0.5000, Val: 0.5000, Test: 0.5000
Epoch: 006, Train: 0.5000, Val: 0.5000, Test: 0.5000
Epoch: 007, Train: 0.5000, Val: 0.5000, Test: 0.5000
Epoch: 008, Train: 0.5000, Val: 0.5000, Test: 0.5000
Epoch: 009, Train: 0.5000, Val: 0.5000, Test: 0.5000
</code></pre><h1 id="批量"><a href="#批量" class="headerlink" title="批量"></a>批量</h1><h2 id="单独传入，stack结果"><a href="#单独传入，stack结果" class="headerlink" title="单独传入，stack结果"></a>单独传入，stack结果</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Net</span>(torch.nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(Net, self).__init__()</span><br><span class="line"></span><br><span class="line">        self.layer = GATConv(in_channels=<span class="number">16</span>, out_channels=<span class="number">16</span>)</span><br><span class="line">        self.layer2 = GATConv(in_channels=<span class="number">16</span>, out_channels=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self,x,edg_index</span>):</span><br><span class="line">        output = torch.stack([self.layer(graph, edge_index=edge_indexi) <span class="keyword">for</span> graph,edge_indexi <span class="keyword">in</span> <span class="built_in">zip</span>(x,edg_index)], dim=<span class="number">0</span>)</span><br><span class="line">        output = torch.stack([self.layer2(graph, edge_index=edge_indexi) <span class="keyword">for</span> graph,edge_indexi <span class="keyword">in</span> <span class="built_in">zip</span>(output,edg_index)], dim=<span class="number">0</span>)</span><br><span class="line">        <span class="comment">#output = torch.sigmoid(output)</span></span><br><span class="line">        <span class="comment">#print(output.shape)</span></span><br><span class="line">        <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torch_geometric.nn <span class="keyword">import</span> GATConv</span><br><span class="line">x = torch.randn((<span class="number">8</span>, <span class="number">207</span>, <span class="number">16</span>))</span><br><span class="line">y = torch.rand([<span class="number">8</span>,<span class="number">207</span>,<span class="number">1</span>]).<span class="built_in">float</span>()</span><br><span class="line">edge_index = torch.randint(high=<span class="number">206</span>, size=(<span class="number">2</span>, <span class="number">1200</span>))</span><br><span class="line"><span class="comment">#print(edge_index.shape)</span></span><br><span class="line"></span><br><span class="line">edge_index = edge_index.repeat(<span class="number">8</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line"><span class="comment">#print(edge_index.shape)</span></span><br><span class="line">model = Net()</span><br><span class="line">optimizer = torch.optim.Adam(params=model.parameters(),lr=<span class="number">0.01</span>)  <span class="comment"># Only perform weight-decay on first convolution.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">model.train()</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">s = time.time()</span><br><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    optimizer.zero_grad()</span><br><span class="line">    out = model(x,edge_index)</span><br><span class="line">    <span class="comment">#print(out.shape)</span></span><br><span class="line">    <span class="comment">#print(y.shape)</span></span><br><span class="line">    loss = F.mse_loss(out, y)</span><br><span class="line">    loss.backward()</span><br><span class="line">    optimizer.step()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(loss.item())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;time:&quot;</span>,time.time()-s)</span><br></pre></td></tr></table></figure>
<pre><code>0.7729121446609497
0.41821303963661194
0.384408563375473
time: 0.09303927421569824
</code></pre><h2 id="Batch-Data"><a href="#Batch-Data" class="headerlink" title="Batch+Data"></a>Batch+Data</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torch_geometric.nn <span class="keyword">import</span> GATConv</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Net</span>(torch.nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(Net, self).__init__()</span><br><span class="line"></span><br><span class="line">        self.layer = GATConv(in_channels=<span class="number">16</span>, out_channels=<span class="number">16</span>)</span><br><span class="line">        self.layer2 = GATConv(in_channels=<span class="number">16</span>,out_channels=<span class="number">1</span>)</span><br><span class="line">        self.dropout = nn.Dropout(<span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self,x,edge_index</span>):</span><br><span class="line"><span class="comment">#         print(&quot;input:&quot;,x.shape)</span></span><br><span class="line">        data_list = [Data(x=x_, edge_index=edge_indexi) <span class="keyword">for</span> x_ , edge_indexi <span class="keyword">in</span> <span class="built_in">zip</span>(x,edge_index)] </span><br><span class="line">        </span><br><span class="line">        batch = Batch.from_data_list(data_list)</span><br><span class="line">        output = self.layer(batch.x, edge_index=batch.edge_index)</span><br><span class="line"><span class="comment">#         print(&quot;output:&quot;,output.shape)</span></span><br><span class="line">        output = self.dropout(output)</span><br><span class="line">        data_list = [Data(x=x_, edge_index=edge_indexi) <span class="keyword">for</span> x_ , edge_indexi <span class="keyword">in</span> <span class="built_in">zip</span>(torch.split(output,x.shape[<span class="number">1</span>]),edge_index)] </span><br><span class="line">        batch = Batch.from_data_list(data_list)</span><br><span class="line">        output = self.layer2(batch.x,batch.edge_index)</span><br><span class="line">        output = self.dropout(output)</span><br><span class="line">        <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torch_geometric.data <span class="keyword">import</span> Data,Batch</span><br><span class="line"><span class="keyword">from</span> torch_geometric.nn <span class="keyword">import</span> GATConv</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">x = torch.randn((<span class="number">8</span>, <span class="number">207</span>, <span class="number">16</span>))</span><br><span class="line">y = torch.rand([<span class="number">8</span>,<span class="number">207</span>,<span class="number">1</span>]).<span class="built_in">float</span>()</span><br><span class="line"></span><br><span class="line">edge_index = torch.randint(high=<span class="number">206</span>, size=(<span class="number">2</span>, <span class="number">1200</span>))</span><br><span class="line"><span class="built_in">print</span>(edge_index.shape)</span><br><span class="line"></span><br><span class="line">edge_index = edge_index.repeat(<span class="number">8</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(edge_index.shape)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">model = Net()</span><br><span class="line">optimizer = torch.optim.Adam(params=model.parameters(),lr=<span class="number">0.01</span>)  <span class="comment"># Only perform weight-decay on first convolution.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">model.train()</span><br><span class="line">s = time.time()</span><br><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    optimizer.zero_grad()</span><br><span class="line">    result = model(x,edge_index)</span><br><span class="line"><span class="comment">#     print(result.shape)</span></span><br><span class="line"><span class="comment">#     print(&quot;output of model&quot;,result.shape)</span></span><br><span class="line"><span class="comment">#     print(y.shape)</span></span><br><span class="line">    result = torch.stack(torch.split(result,x.shape[<span class="number">1</span>]))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;reshape the output:&quot;</span>,result.shape)</span><br><span class="line">    loss = F.mse_loss(result, y)</span><br><span class="line">    loss.backward()</span><br><span class="line">    optimizer.step()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(loss.item())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;time:&quot;</span>,time.time()-s)</span><br></pre></td></tr></table></figure>
<pre><code>torch.Size([2, 1200])
torch.Size([8, 2, 1200])
reshape the output: torch.Size([8, 207, 1])
2.3954498767852783
reshape the output: torch.Size([8, 207, 1])
1.1830278635025024
reshape the output: torch.Size([8, 207, 1])
0.9167585372924805
time: 0.05799269676208496
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torch_geometric.data <span class="keyword">import</span> Data,Batch</span><br><span class="line"><span class="keyword">from</span> torch_geometric.nn <span class="keyword">import</span> GATConv</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line">x = torch.randn((<span class="number">8</span>, <span class="number">207</span>, <span class="number">16</span>))</span><br><span class="line">y = torch.rand([<span class="number">8</span>,<span class="number">207</span>,<span class="number">1</span>]).<span class="built_in">float</span>()</span><br><span class="line"></span><br><span class="line">edge_index = torch.randint(high=<span class="number">206</span>, size=(<span class="number">2</span>, <span class="number">1200</span>))</span><br><span class="line"><span class="built_in">print</span>(edge_index.shape)</span><br><span class="line"></span><br><span class="line">edge_index = edge_index.repeat(<span class="number">8</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(edge_index.shape)</span><br><span class="line"></span><br><span class="line">data_list = [Data(x=x_, edge_index=edge_indexi) <span class="keyword">for</span> x_ , edge_indexi <span class="keyword">in</span> <span class="built_in">zip</span>(x,edge_index)] </span><br><span class="line">batch = Batch.from_data_list(data_list)</span><br><span class="line">layer = GATConv(in_channels=<span class="number">16</span>, out_channels=<span class="number">2</span>)</span><br><span class="line">result = layer(batch.x, edge_index=batch.edge_index)</span><br><span class="line"><span class="built_in">print</span>(result.shape)</span><br></pre></td></tr></table></figure>
<pre><code>torch.Size([2, 1200])
torch.Size([8, 2, 1200])
torch.Size([1656, 2])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = torch.rand([<span class="number">2</span>, <span class="number">2</span>, <span class="number">40000</span>])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> x:</span><br><span class="line">    <span class="built_in">print</span>(i.shape)</span><br></pre></td></tr></table></figure>
<pre><code>torch.Size([2, 40000])
torch.Size([2, 40000])
</code></pre><h1 id="批量邻接矩阵转换"><a href="#批量邻接矩阵转换" class="headerlink" title="批量邻接矩阵转换"></a>批量邻接矩阵转换</h1><h2 id="转换实现"><a href="#转换实现" class="headerlink" title="转换实现"></a>转换实现</h2><h3 id="转换完stack"><a href="#转换完stack" class="headerlink" title="转换完stack"></a>转换完stack</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">adj2coo</span>(<span class="params">self,Ab</span>):</span><br><span class="line">        <span class="keyword">import</span> scipy.sparse <span class="keyword">as</span> sp</span><br><span class="line">        <span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">        adj = sp.coo_matrix(Ab)  <span class="comment"># 转换成coo_matrix矩阵</span></span><br><span class="line">        edge_attr = adj.data  <span class="comment"># 边权值</span></span><br><span class="line">        indices = np.vstack((adj.row, adj.col))  <span class="comment"># 我们需要的coo形式的edge_index</span></span><br><span class="line">        edge_index = torch.LongTensor(indices)  <span class="comment"># PyG需要的edge_index</span></span><br><span class="line"></span><br><span class="line">        edge_attr = torch.FloatTensor(edge_attr)  <span class="comment"># to float tensor</span></span><br><span class="line">        <span class="built_in">print</span>(edge_index.shape,edge_attr.shape)</span><br><span class="line">        <span class="keyword">return</span> edge_index,edge_attr</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">edg_indexH, edge_attrH = torch.stack([self.adj2coo(i)[<span class="number">0</span>] <span class="keyword">for</span> i <span class="keyword">in</span> scoadj], dim=<span class="number">0</span>), torch.stack(</span><br><span class="line">            [self.adj2coo(i)[<span class="number">1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> adj], dim=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h3 id="一次性解决"><a href="#一次性解决" class="headerlink" title="一次性解决"></a>一次性解决</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">adj2edge_index</span>(<span class="params">self,A</span>):</span><br><span class="line">       <span class="keyword">import</span> scipy.sparse <span class="keyword">as</span> sp</span><br><span class="line">       <span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">       edg_indexAll = torch.zeros(<span class="number">0</span>,dtype=torch.int64)</span><br><span class="line">       edg_attrAll = torch.zeros(<span class="number">0</span>,dtype=torch.float32)</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> b <span class="keyword">in</span> A:</span><br><span class="line">           adj = sp.coo_matrix(b)  <span class="comment"># 转换成coo_matrix矩阵</span></span><br><span class="line">           edge_attr = adj.data  <span class="comment"># 边权值</span></span><br><span class="line">           indices = np.vstack((adj.row, adj.col))  <span class="comment"># 我们需要的coo形式的edge_index</span></span><br><span class="line">           edge_index = torch.LongTensor(indices)  <span class="comment"># PyG需要的edge_index</span></span><br><span class="line"></span><br><span class="line">           edge_attr = torch.FloatTensor(edge_attr)  <span class="comment"># to float tensor</span></span><br><span class="line">           edg_indexAll = torch.cat((edg_indexAll, edge_index))</span><br><span class="line">           edg_attrAll = torch.cat((edg_attrAll, edge_attr))</span><br><span class="line"></span><br><span class="line">       <span class="comment">#print(&quot;edg&quot;,edg_indexAll.view(A.shape[0],2,-1).shape)</span></span><br><span class="line">       <span class="comment">#print(edg_attrAll.view(A.shape[0],-1).shape)</span></span><br><span class="line">       <span class="keyword">return</span> edg_indexAll.view(A.shape[<span class="number">0</span>],<span class="number">2</span>,-<span class="number">1</span>),edg_attrAll.view(A.shape[<span class="number">0</span>],-<span class="number">1</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="应用到模型"><a href="#应用到模型" class="headerlink" title="应用到模型"></a>应用到模型</h2><h3 id="模型中传参"><a href="#模型中传参" class="headerlink" title="模型中传参"></a>模型中传参</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x3 = self.relu(</span><br><span class="line">            torch.stack(</span><br><span class="line">                [self.gc6(graph, edge_index=self.adj2coo(edge)[<span class="number">0</span>], edge_attr=self.adj2coo(edge)[<span class="number">1</span>]) <span class="keyword">for</span> graph, edge <span class="keyword">in</span></span><br><span class="line">                 <span class="built_in">zip</span>(x3_h,A)],</span><br><span class="line">                dim=<span class="number">0</span>))</span><br></pre></td></tr></table></figure>
<h3 id="Batch-Data-1"><a href="#Batch-Data-1" class="headerlink" title="Batch+Data"></a>Batch+Data</h3><p><strong>效率更高，如一个epoch前面是280s,后面是90s</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torch_geometric.data <span class="keyword">import</span> Data,Batch</span><br><span class="line">data_list = [Data(x = x_,edge_ index=self.adj2coo(edge)[<span class="number">0</span>] ,edge_attr=self.adj2coo(edge)[<span class="number">1</span>]) <span class="keyword">for</span></span><br><span class="line">x_ ,edge <span class="keyword">in</span> <span class="built_in">zip</span>(x, A) ]</span><br><span class="line">batchH = Batch.from_data_list(data_listata_list)</span><br><span class="line">x1_h = self. relu(self. gc1(batchH.x， edge_index=batchH. edge_indexedge_attr=batchH.edge_attr ))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>图神经网络</category>
      </categories>
      <tags>
        <tag>PyG</tag>
        <tag>GNN</tag>
      </tags>
  </entry>
</search>
